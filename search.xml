<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03-数组中重复的数字</title>
    <url>/2021/06/04/03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>2 &lt;= n &lt;= 100000</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" >https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
<li>HashSet，即是<a class="link"   href="https://zh.cppreference.com/w/cpp/container/unordered_set" >unordered_set<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>遍历<code>nums</code>值，将值一一插入<code>set</code>，当再次插入已经插入的值的时候，表现为<code>set.insert(value).second</code>值为<code>false</code>，即找到重复数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用HashSet插入数，当值已经插入过时set.insert(value).second值为false</span></span><br><span class="line"><span class="comment">// 即找到重复的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> value = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (!set.<span class="built_in">insert</span>(value).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>04-二维数组中的查找</title>
    <url>/2021/06/04/04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<span id="more"></span>

<p><strong>示例:</strong><br>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。<br>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong><br><code>0 &lt;= n &lt;= 1000</code><br><code>0 &lt;= m &lt;= 1000</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" >https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>本题完全可以使用暴力搜索完成，但是。。。<br>“每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序”，说明有更明智的方法。<br>我们可以从右上角开始判断，当目标值小于当前元素左移，否则下移，如此反复，直到得出结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不从左上角开始判断的原因使是：向下，向右都是递增的</span></span><br><span class="line"><span class="comment">// 不从右下角开始判断的原因使是：向上，向左都是递减的</span></span><br><span class="line"><span class="comment">// 这里选择右上角开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n_size = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m_size = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = m_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &lt; n_size &amp;&amp; m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> val = matrix[n][m];</span><br><span class="line">            <span class="keyword">if</span> (target == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; val) &#123;</span><br><span class="line">                m -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>05-替换空格</title>
    <url>/2021/06/04/05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。 </p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof" >https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/string/basic_string" >string<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>这题比较简单，主要考查的是对<code>string</code>类的了解程度，有很多办法，我使用的是<code>replace</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> idx = s.<span class="built_in">find_first_of</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (idx == string::npos) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            s.<span class="built_in">replace</span>(idx, <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>06-从尾到头打印链表</title>
    <url>/2021/06/04/06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof" >https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>这题相对简单，考查的是对<code>vector</code>的了解程度，以及链表遍历方法。反着输出值可以使用<code>insert</code>指定插入位置为<code>begin</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>07-重建二叉树</title>
    <url>/2021/06/05/07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<span id="more"></span>

<p>例如，给出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" >https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
<li>HashMap，即是<a class="link"   href="https://zh.cppreference.com/w/cpp/container/unordered_map" >unordered_map<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>这题主要考查的是对二叉树前序遍历，中序遍历和递归的理解程度，它们是以这样分布的：<br>前序遍历：<code>[根节点, [左子树], [右子树]]</code><br>中序遍历：<code>[[左子树], 根结点, [右子树]]</code></p>
<p>假设有这么一课二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br></pre></td></tr></table></figure>
<p>前序遍历为：[3, 9, 20]<br>中序遍历为：[9, 3, 20]</p>
<p>前序遍历的第一个元素为3，即3是根节点，左右子树节点分别为[9]，[20]，把它们看成一个单独的树，他们的前序分别为[9]，[20]，第一个元素即为根节点，所以还原成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildInner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历第一个值就是根节点的值</span></span><br><span class="line">        <span class="type">int</span> root_preorder_index = preorder_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得值</span></span><br><span class="line">        <span class="type">int</span> root_val = preorder[root_preorder_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到它在中序遍历中的位置，为了计算左右子树的个数</span></span><br><span class="line">        <span class="type">int</span> root_inorder_index = map[root_val];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算出左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> sub_size = root_inorder_index - inorder_left;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildInner</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + sub_size, inorder_left, root_inorder_index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildInner</span>(preorder, inorder, preorder_left + sub_size + <span class="number">1</span>, preorder_right, root_inorder_index + <span class="number">1</span>, inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = preorder.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了快速找到每个根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            map[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildInner</span>(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>09-用两个栈实现队列</title>
    <url>/2021/06/05/09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>1 &lt;= values &lt;= 10000</code><br><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" >https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/stack" >stack<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>我遇到的问题是题目看不懂，看了leetcode @Modest Almeida的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">1.[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] 这里是要执行的方法，从左到右执行。</span><br><span class="line">2.[[],[3],[],[]]对应上面的方法，是上面方法的参数。</span><br><span class="line">3.CQueue和deleteHead方法不需要指定数字，只有添加才需要指定数字</span><br><span class="line"></span><br><span class="line">1.创建队列，返回值为null</span><br><span class="line">2.将3压入栈，返回值为null</span><br><span class="line">3.将栈底的元素删除，也就是消息队列中先进来的元素，所以是deleteHead，返回该元素的数值，所以为3</span><br><span class="line">4.继续删除栈底的元素，但是没有元素了，所以返回-1</span><br><span class="line"></span><br><span class="line">所以就有了下面的输出 输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p>本题考查的是对队列和栈的了解，队列的特点是先进先出(FIFO)，栈的特点是先进后出(FILO)，我们可以把一个栈用作<code>appendTail</code>，一个栈用作<code>deleteHead</code>，当要<code>deleteHead</code>时，将<code>stack1</code>的数据倒写到<code>stack2</code>，此时<code>stack2</code>即为队列的布局，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">high address -&gt; low address</span><br><span class="line"></span><br><span class="line">appendTail 1:</span><br><span class="line">stack1: [1],</span><br><span class="line">stack2: []</span><br><span class="line"></span><br><span class="line">appendTail 2:</span><br><span class="line">stack1: [1， 2],</span><br><span class="line">stack2: []</span><br><span class="line"></span><br><span class="line">deleteHead:</span><br><span class="line">stack1: [],</span><br><span class="line">stack2: [2, 1],</span><br><span class="line">stack2: [2],</span><br><span class="line"></span><br><span class="line">deleteHead:</span><br><span class="line">stack1: [],</span><br><span class="line">stack2: [1],</span><br><span class="line">stack2: [],</span><br></pre></td></tr></table></figure>

<p>根据分析，可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>10-I-斐波那契数列</title>
    <url>/2021/06/05/10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>0 &lt;= n &lt;= 100</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" >https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li>无</li>
</ul>
<p>本题主要考查的是对Fibonacci的理解，并且看看你是不是只会暴力递归（指没有记录算过的值）；这里我们可以发现，某一项的值与前两项有关，所以我们只需要记录每次的前两项即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = 3</span></span><br><span class="line"><span class="comment">// one = 1, two = 0</span></span><br><span class="line"><span class="comment">// res = 1 + 0</span></span><br><span class="line"><span class="comment">// two = one</span></span><br><span class="line"><span class="comment">// one = res</span></span><br><span class="line"><span class="comment">// res = 1 + 1 = 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (one + two) % <span class="number">1000000007</span>;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>10-II-青蛙跳台阶问题</title>
    <url>/2021/06/05/10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>0 &lt;= n &lt;= 100</code><br>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" >https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li>无</li>
</ul>
<p>本题考查的其实也是斐波那契数列，设跳上<code>n</code>级台阶有<code>f(n)</code>种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上<code>1</code>级或<code>2</code>级台阶。<br>当为<code>1</code>级台阶： 剩<code>n−1</code>个台阶，此情况共有<code>f(n-1)</code>种跳法；<br>当为<code>2</code>级台阶： 剩<code>n−2</code>个台阶，此情况共有<code>f(n-2)</code>种跳法。<br>即<code>f(n) = f(n - 1) + f(n - 2)</code>，根据提示有<code>f(0) = 1</code>，可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (one + two) % <span class="number">1000000007</span>;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>11-旋转数组的最小数字</title>
    <url>/2021/06/05/11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" >https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构</p>
<ul>
<li>无</li>
</ul>
<p>做这题极易一把梭写出<code>sort</code>取值，或者调用相关函数，或者又像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽说能够通过测试，但是在面试时估计就会被HR记住。看题目可以知道原来的数组是个递增序列，然后把某一段提到前面来了，所以这里有两个递增序列。最小值在第二个递增区的第一个值，这里可以使用二分法(还有特殊情况)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rignt = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// [01111] -&gt; [11101]</span></span><br><span class="line">        <span class="comment">// 这种情况无法使用二分法，所以顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[left] == numbers[rignt]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[left] &lt; numbers[rignt]) &#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (numbers[left] &gt; numbers[rignt]) &#123;</span><br><span class="line">            <span class="comment">// [3, 4, [5, 1] ,2]</span></span><br><span class="line">            <span class="comment">// 5 &gt; 1</span></span><br><span class="line">            <span class="comment">// 3 - 2 = 1</span></span><br><span class="line">            <span class="keyword">if</span> (rignt - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = rignt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + rignt) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为真说明mid指向的值在第一个递增区，缩小范围</span></span><br><span class="line">            <span class="comment">// 否则说明其在第二个递增区，缩小范围</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[left] &lt;= numbers[mid]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rignt = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>12-矩阵中的路径</title>
    <url>/2021/06/05/12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="leetcode"></p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>1 &lt;= board.length &lt;= 200</code><br><code>1 &lt;= board[i].length &lt;= 200</code><br><code>board 和 word 仅由大小写英文字母组成</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" >https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/string/basic_string" >string<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>本题考查的是广度优先遍历，遍历需要个起点，然后遍历还需要记录是否为访问过某个值（不然打圈圈就没意思了），还有就是要考虑到遍历何时结束。这里的起点便是要查找的字符串的第一个值，结束即是找到了整个字符串，关于记录是否为访问过某个值，这里可以在数组中修改字符为’\0’，为访问过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col, string&amp; word, <span class="type">int</span> found)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断是否找到了，found为找到的字符数</span></span><br><span class="line">        <span class="keyword">if</span> (found == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断row和col是否越界</span></span><br><span class="line">	<span class="comment">// 再判断board[row][col] == &#x27;\0&#x27;</span></span><br><span class="line">	<span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.<span class="built_in">size</span>() || </span><br><span class="line">            col &lt; <span class="number">0</span> || col == board[<span class="number">0</span>].<span class="built_in">size</span>() ||</span><br><span class="line">            board[row][col] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果找到对应的字符，找到字符数加1</span></span><br><span class="line">	<span class="comment">// 标记为访问过</span></span><br><span class="line">	<span class="comment">// 周围遍历完后恢复字符</span></span><br><span class="line">	<span class="comment">// 否则直接false</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == word[found]) &#123;</span><br><span class="line">            found += <span class="number">1</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="type">bool</span> res = <span class="built_in">bfs</span>(board, row - <span class="number">1</span>, col, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row + <span class="number">1</span>, col, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row, col + <span class="number">1</span>, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row, col - <span class="number">1</span>, word, found);</span><br><span class="line">            found -= <span class="number">1</span>;</span><br><span class="line">            board[row][col] = word[found];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 这可不是脱裤子放屁</span></span><br><span class="line">                    <span class="comment">// 直接return bfs(board, row, col, word, 0) 是不正确的</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">bfs</span>(board, row, col, word, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>13-机器人的运动范围</title>
    <url>/2021/06/07/13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p><strong>题目：</strong><br>上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>1 &lt;= n,m &lt;= 100</code><br><code>0 &lt;= k &lt;= 20</code></p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" >https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>题解：</strong><br>使用的数据结构：</p>
<ul>
<li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>本题和上一道矩阵中的路径，思路基本是相同的，需要注意的是我们得建立一个表，来判断节点是否被访问过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += row % <span class="number">10</span>;</span><br><span class="line">            row /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += col % <span class="number">10</span>;</span><br><span class="line">            col /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == m ||</span><br><span class="line">            col &lt; <span class="number">0</span> || col == n ||</span><br><span class="line">            <span class="built_in">sum</span>(row, col) &gt; k ||</span><br><span class="line">            map[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">bfs</span>(row - <span class="number">1</span>, col, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row + <span class="number">1</span>, col, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row, col - <span class="number">1</span>, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row, col + <span class="number">1</span>, m, n, k, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n, k, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Linux 关于Gnome-Terminal透明</title>
    <url>/2018/02/10/arch-linux-%E5%85%B3%E4%BA%8Egnome-terminal%E9%80%8F%E6%98%8E/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近装了<a class="link"   href="https://www.archlinux.org/" >Arch<i class="fas fa-external-link-alt"></i></a>来玩玩，装了gnome桌面环境，当然就要开始美化了，美化到最后，发现我使用最多的终端已经没有透明功能，查阅资料后，得知安装<a class="link"   href="https://aur.archlinux.org/" >aur<i class="fas fa-external-link-alt"></i></a>里的<a class="link"   href="https://aur.archlinux.org/packages/gnome-terminal-fedora" >gnome-terminal-fedora<i class="fas fa-external-link-alt"></i></a>即可，于是乎我发现了一些问题，直接用yaourt安装会出错，_<strong>可以直接在安装过程中修改PKGBUILD，也可以手动，本教程讲的手动修改</strong>_</p>
<h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>从aur里同步两个必要的包</p>
<p>git clone <a class="link"   href="https://aur.archlinux.org/vte3-notification.git" >https://aur.archlinux.org/vte3-notification.git<i class="fas fa-external-link-alt"></i></a></p>
<p>以及</p>
<p>git clone <a class="link"   href="https://aur.archlinux.org/gnome-terminal-fedora.git" >https://aur.archlinux.org/gnome-terminal-fedora.git<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-11-51.png"> 然后进入vte3-notification，并执行</p>
<p>makepkg</p>
<p>之后会出现如图所示的错误 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-13-38.png"> 这就是报错，现在要解决这些错误，打开报错链接，发现403报错，后来经过进一步查看，_<strong>发现网站域名已从pkgs.fedoraproject.org变成src.fedoraproject.org</strong>_ 知道原因以后就轻松了</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在vte3-notification目录下，输入</p>
<p>vi PKGBUILD</p>
<p>将pkgs都改成src即可 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-22-23.png"> 同理，进入gnome-terminal-fedora，打开PKGBUILD，将pkgs改成src即可</p>
<h1 id="打包安装（安装顺序不能乱，因为terminal编译对第一个软件包有依赖性）"><a href="#打包安装（安装顺序不能乱，因为terminal编译对第一个软件包有依赖性）" class="headerlink" title="打包安装（安装顺序不能乱，因为terminal编译对第一个软件包有依赖性）"></a>打包安装（安装顺序不能乱，因为terminal编译对第一个软件包有依赖性）</h1><p>先在vte3-notification目录下输入</p>
<p>makepkg</p>
<p>就开始编译了（要注意的是Python版本得是3或以上，因为我android需要2.7版本，所以编译过程中发生了报错） 编译完成后 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-28-35.png"> 之后输入命令开始安装</p>
<p>sudo pacman -U vte3-notification-0.50.2-1-x86_64.pkg.tar.xz vte-notification-common-0.50.2-1-any.pkg.tar.xz</p>
<p>如图，安装即可 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-31-09.png"> 进入gnome-terminal-fedora目录 同理，输入命令后，安装即可，如图 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-31-09.png"> 打开gnome-terminal-fedora终端即可，我把原来的gnome-terminal卸载了 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-21-43-12.png"></p>
<h1 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h1><p><img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-20-26-43.png"></p>
<h1 id="最终软件包下载"><a href="#最终软件包下载" class="headerlink" title="最终软件包下载"></a>最终软件包下载</h1><p><a class="link"   href="https://drive.google.com/file/d/1f_jeUJ9SkPifsm7XkaJsYxi55Rx50NYk/view?usp=sharing" >gnome-terminal-fedora<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://drive.google.com/file/d/1nFo603Iz9OuiVPCyv4gUodIFYGPo5CCH/view?usp=sharing" >vte-notification<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://drive.google.com/file/d/1kcREzawaMKAUjhOubA66Q72JBIiV76FE/view?usp=sharing" >vte3-notification<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Linux基本环境安装文本与视频教程(不含桌面环境)</title>
    <url>/2018/05/06/arch-linux%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%96%87%E6%9C%AC%E4%B8%8E%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E4%B8%8D%E5%90%AB%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><em>前言</em></p>
<p><strong>在很早之前就想发布一个安装<a href="https://zh.wikipedia.org/wiki/Arch_Linux"><em>arch_linux</em></a>的教程，可是一直没有时间，最近一名网友想安装arch，所以我就写了这篇教程，还做了个视频</strong></p>
<p><em>视频教程</em></p>
<p><a class="link"   href="https://www.youtube.com/watch?v=nH7NuSXKPBQ" >Youtube<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://spxg-my.sharepoint.com/:v:/g/personal/spxg_spxg_me/EfW0BObAeGBJqF3CQb_UTsMBRIf0AeHTP2ptlgvQnDyHow?e=EdesMG" >Onedrive<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://drive.google.com/open?id=1U8_4qk-u1Hh9A7qkuIoyefPaBWhodw0W" >Google Drive<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>      支持64位的电脑一台</p>
<p>有稳定的网络环境(arch为在线安装)</p>
<p>       有可以用的引导设备(至于<a href="https://www.archlinux.org/download/"><strong>镜像</strong></a>怎么写入并且引导，不做阐述)</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>首先并不困难地进入了命令行</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180505235341.png"></p>
<h3 id="测试网络联通性"><a href="#测试网络联通性" class="headerlink" title="测试网络联通性"></a>测试网络联通性</h3><p><code>ping wordpress-1253676827.file.myqcloud.com</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180505235453.png"></p>
<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p><code>nano /etc/pacman.d/mirrorlist</code> 把第一个地址改成<a class="link"   href="http://mirrors.aliyun.com/xxxx%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%8C%E8%BF%99%E6%98%AF%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E9%95%9C%E5%83%8F%E7%AB%99(%E8%A7%86%E9%A2%91%E5%90%8E%E9%9D%A2%E5%9B%A0%E4%B8%BA%E5%90%8C%E6%AD%A5%E6%85%A2%EF%BC%8C%E6%88%91%E5%8F%88%E6%94%B9%E4%BA%86%E5%9C%B0%E5%9D%80)" >http://mirrors.aliyun.com/xxxx，如图，这是阿里云的镜像站(视频后面因为同步慢，我又改了地址)<i class="fas fa-external-link-alt"></i></a> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506001823.png"> 改完后，输入CTRL+X，然后选择y保存退出</p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><code>fdisk -l</code> 这个命令是用来查看硬盘设备的，找到我们要分区的硬盘，之后输入 <code>fdisk /dev/sdax</code>  <em>&#x2F;&#x2F;</em> <em>我这里是sda</em> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506002409.png"> 我的分区计划是</p>
<ul>
<li>EFI:200MB</li>
<li>根目录:10GB</li>
<li>HOME:9.8GB</li>
</ul>
<p>如果是gpt分区可以输入g，然后再输入n，mbr直接输入n创建分区，回车两次，然后输入你要的空间大小，可以表示为+xM或者+xGB，回车，再创建，以此类推，最后输入w保存，如图 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506003803.png"> 分区好后，我们可以通过命令来查看分区情况，输入lsblk <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506004255.png"> 可以清楚的看到，sda硬盘被分了三个区，接下来我们要做的就是格式化分区</p>
<ul>
<li>efi:fat分区格式</li>
<li>根目录:ext日志式</li>
<li>HOME:ext日志式</li>
</ul>
<p>所以我们输入命令，请具体情况具体分析 <code>mkfs.fat -F32 /dev/sdax</code> <em>&#x2F;&#x2F; 我这x&#x3D;1</em> <em><strong>mbr的输入mkfs.ext4 &#x2F;dev&#x2F;sdax</strong></em> <code>mkfs.ext4 /dev/sday</code>  <em>&#x2F;&#x2F;</em> <em>我这y&#x3D;2</em> <code>mkfs.ext4 /dev/sdaz</code> <em>&#x2F;&#x2F;</em> <em>我这z&#x3D;3</em> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506004442.png"></p>
<h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>依次输入命令 <code>mount /dev/sda2 /mnt</code>  <em>&#x2F;&#x2F; 挂载sda2分区到&#x2F;mnt，也就是装完系统后的根目录</em> <code>mkdir -p /mnt/home</code> <em>&#x2F;&#x2F; 创建&#x2F;mnt&#x2F;home目录，也就是装完系统后的&#x2F;home目录</em> <code>mount /dev/sda3 /mnt/home</code> <em>&#x2F;&#x2F; 挂载sda3分区到&#x2F;mnt&#x2F;home，也就是装完系统后的&#x2F;home</em> <code>mkidr -p /mnt/boot/EFI</code> <em>&#x2F;&#x2F; 创建&#x2F;mnt&#x2F;boot&#x2F;EFI目录，也就是装完系统后的&#x2F;boot&#x2F;EFI目录，<strong>mbr的输入mkidr -p &#x2F;mnt&#x2F;boot</strong></em> <code>mount /dev/sda1 /mnt/boot/EFI</code> <em>&#x2F;&#x2F; 挂载sda1分区到&#x2F;mnt&#x2F;boot&#x2F;EFI，也就是装完系统后的&#x2F;boot&#x2F;EFI，<strong>mbr的输入mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;boot</strong></em> <strong>注意顺序不能乱，因为挂&#x2F;mnt的时候&#x2F;mnt&#x2F;home和&#x2F;mnt&#x2F;boot&#x2F;EFI会莫名的消失</strong> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506005530.png"></p>
<h3 id="安装基本环境"><a href="#安装基本环境" class="headerlink" title="安装基本环境"></a>安装基本环境</h3><p>一路回车即可 <code>pacstrap -i /mnt base base-devel</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506005751.png"></p>
<h3 id="生成分区表"><a href="#生成分区表" class="headerlink" title="生成分区表"></a>生成分区表</h3><p><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code> <code>cat /mnt/etc/fstab</code> <em>&#x2F;&#x2F; 检验分区表是否正确</em> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506005954.png"></p>
<h3 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h3><p><code>arch-chroot /mnt /bin/bash</code></p>
<h3 id="然后修改语言和时区"><a href="#然后修改语言和时区" class="headerlink" title="然后修改语言和时区"></a>然后修改语言和时区</h3><p><code>nano /etc/locale.gen</code> 把en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 的注释取消，然后保存，退出 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506010143.png"> 接着输入 <code>locale-gen</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506010245.png"> <code>echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</code> <code> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code> <code> hwclock --systohc --utc</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506010457.png"> 接着就可以安装引导了</p>
<h3 id="UEFI引导"><a href="#UEFI引导" class="headerlink" title="UEFI引导"></a>UEFI引导</h3><p><code>pacman -S dosfstools grub efibootmgr</code> <code>grub-install --target=x86_64-efi --efi-directory=/boot/EFI --recheck</code> <code> grub-mkconfig -o /boot/grub/grub.cfg</code> <em>&#x2F;&#x2F; 生成GRUB菜单</em></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506111130.png"></h3><h3 id="MBR引导"><a href="#MBR引导" class="headerlink" title="MBR引导"></a>MBR引导</h3><p> <code>pacman -S grub os-prober</code> <code> grub-install --recheck /dev/sda</code> <strong>&#x2F;&#x2F; 注意:sda不带分区号!</strong> <code> grub-mkconfig -o /boot/grub/grub.cfg</code> <em>&#x2F;&#x2F; 生成GRUB菜单</em></p>
<h3 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h3><p><code>passwd</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506112013.png"></p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p> <code>useradd -m -g users -s /bin/bash 用户名</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506111950.png"></p>
<h3 id="修改添加的用户的密码"><a href="#修改添加的用户的密码" class="headerlink" title="修改添加的用户的密码"></a>修改添加的用户的密码</h3><p><code>passwd 用户名</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506112031.png"></p>
<h3 id="赋予添加用户sudo权限"><a href="#赋予添加用户sudo权限" class="headerlink" title="赋予添加用户sudo权限"></a>赋予添加用户sudo权限</h3><p> <code>nano /etc/sudoers</code> &#x2F;&#x2F; <strong>root ALL&#x3D;(ALL) ALL 下面添加 用户名 ALL&#x3D;(ALL) ALL 保存退出</strong> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506111928.png"></p>
<h3 id="最后，退出重启即可"><a href="#最后，退出重启即可" class="headerlink" title="最后，退出重启即可"></a>最后，退出重启即可</h3><p><code>exit</code> <code>reboot</code> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/05/TIM%E6%88%AA%E5%9B%BE20180506115133.png"></p>
<p><em>其他</em></p>
<p>关于图形化的教程我就不赘述了，可以去网上查找其他资料</p>
<p><strong>各种美化后的效果图</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/02/Screenshot-from-2018-02-10-20-26-43.png"></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>AUR源安装软件 校验不通过的解决办法 例:网易云音乐</title>
    <url>/2017/05/06/aur%E6%BA%90%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6-%E6%A0%A1%E9%AA%8C%E4%B8%8D%E9%80%9A%E8%BF%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E4%BE%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<p> <em><strong>经过</strong></em></p>
<p> <em>今天太过无聊，就装<a class="link"   href="https://manjaro.org/" >Manjaro linux<i class="fas fa-external-link-alt"></i></a> 17.01来消遣消遣，以打发时间（顺便说一下，17.01用U盘引导的建议使用<a class="link"   href="https://rufus.akeo.ie/" >rufus<i class="fas fa-external-link-alt"></i></a>来制作，必须用DD模式）</em> 我用的系统必须得装有网易云音乐啊，然后就用安装软件安装</p>
<ul>
<li>先是这样</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-17-11-29%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-1.png"></p>
<ul>
<li>然后开始安装，变成了这样</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-17-12-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png">   <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/17c1fa5eddcdef96.jpg">我的网易云还没装就夭折了？ service.html是个什么玩意儿，似乎无关紧要。我在想能不能自己构建一个出来呢，把MD5修正了装上去，或者直接删掉验证更快，示范第一种</p>
<p><strong><em>开始动手</em></strong></p>
<ul>
<li>我先来到了<a class="link"   href="https://aur.archlinux.org/packages" >AUR源的网站<i class="fas fa-external-link-alt"></i></a> ，找到了网易云音乐的项目</li>
</ul>
<p><img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-17-21-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-1024x576.png"></p>
<ul>
<li>看了看 <a class="link"   href="http://music.163.com/html/web2/service.html" >service.tml的内容<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-17-20-46%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-1024x576.png">    <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/42805acb2ed6e66f.jpg">大概是条款变动了，作者没更新</p>
<ul>
<li>开始同步修改，输入命令   git clone <a class="link"   href="https://aur.archlinux.org/netease-cloud-music.git" >https://aur.archlinux.org/netease-cloud-music.git<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-17-19-34%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"> 有这几个文件<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-35-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png">，其中PKGBUILD和.SPCINFO都有对文件的MD5的验证内容，我们从这动手脚</p>
<ul>
<li>下载<a class="link"   href="http://music.163.com/html/web2/service.html" >service.html<i class="fas fa-external-link-alt"></i></a>，记录其MD5，修改</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-39-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"> 打开PKGBUILD，修改为正确值 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-41-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"> 打开.SECINFO,修改为正确值 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-43-48%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p>
<ul>
<li>构建</li>
</ul>
<p>在同步目录输入makepkg <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-54-00%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p>
<ul>
<li>安装</li>
</ul>
<p>输入命令 sudo pacman -U netease-cloud-music-1.0.0-3-x86_64.pkg.tar.xz <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-55-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p>
<ul>
<li>安装成功</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/2017-05-06-18-57-04%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/d49e95cfe2995aa.png">  </p>
<p><em><strong>注意</strong></em></p>
<p>本教程应该同样适用于类似问题</p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第10章编程题-GPS数据处理</title>
    <url>/2019/08/19/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC10%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-gps%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190819165743.png"> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190819165726.png">  </p>
<h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><p>题目依旧很长，但是这次每一句都得仔细看，我的直觉告诉我这题不简单，这题我接触一个新的东西：异或，也让我学到了进制的转化，更让我学到了看清题目的重要性，题目重点如下</p>
<ol>
<li>每个字段的大小（长度）不一 （说明当找字符时不能只是数数）</li>
<li>“<em>”为校验和识别符，其后面的两位数为校验和，代表了“$”和“</em>”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80</li>
<li>十六进制值中是会出现A-F的大写字母的</li>
<li>你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的 END</li>
<li>从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出</li>
<li>其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0</li>
</ol>
<p>读完题目，分析重点完后，发现此题最好需要用到字符串函数（为什么说最好呢？因为讨论区内有位厉害的同学没用到），所以需要有string.h头文件，至于字符串大小就整个1000吧，大点保险些。作为压轴题，我们最好写的优秀些，比如用上函数的知识啥的<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">，初步可以写出如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gettime</span><span class="params">(<span class="type">char</span> *gps, <span class="type">int</span> *hour, <span class="type">int</span> *minutes, <span class="type">int</span> *second)</span>; <span class="comment">//获取时间，且因为变量不是全局的，所以传指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hour, minutes, second;</span><br><span class="line">    <span class="type">char</span> gps[MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;; <span class="comment">//日常初始化</span></span><br><span class="line">    <span class="type">char</span> end[] = <span class="string">&quot;END&quot;</span>; <span class="comment">//END的字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, gps); <span class="comment">//因为字符串是一连串的，中间没有空格，所以使用scanf即可，用gets也行</span></span><br><span class="line">        gettime(gps, &amp;hour, &amp;minutes, &amp;second);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">strcmp</span>(gps, end) != <span class="number">0</span>); <span class="comment">//判断是否为END，是，就停止</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, hour, minutes, second); <span class="comment">//最后的正确语句输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就该考虑如何获取正确时间了，看完重点后，就可以知道第一步应该是判断是否为$GPRMC语句，之后再判断是否为有效语句。按照题目，我们得先算异或值，然后把它转化成16进制，与校验值相符后，再判断是否已定位。都满足的话，换算时间。代码可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gettime</span><span class="params">(<span class="type">char</span> *gps, <span class="type">int</span> *hour, <span class="type">int</span> *minutes, <span class="type">int</span> *second)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gps[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span> &amp;&amp; gps[<span class="number">1</span>] == <span class="string">&#x27;G&#x27;</span> &amp;&amp; gps[<span class="number">2</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; gps[<span class="number">3</span>] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; gps[<span class="number">4</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; gps[<span class="number">5</span>] == <span class="string">&#x27;C&#x27;</span>) <span class="comment">//判断是否为$GPRMC语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> hex[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;; <span class="comment">//转换过程中会出现A-F， 代表10 - 15的值</span></span><br><span class="line">        <span class="type">int</span> xor, hexxor, i;</span><br><span class="line">        <span class="type">char</span> savehex[MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;, check[MAX] = &#123;<span class="string">&quot;0&quot;</span>&#125;; <span class="comment">//日常初始化</span></span><br><span class="line"></span><br><span class="line">        xor = gps[<span class="number">1</span>] ^ gps[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i++)</span><br><span class="line">            xor ^= gps[i];</span><br><span class="line">        xor = xor % <span class="number">65536</span>; <span class="comment">//获取异或值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; xor != <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hexxor = xor % <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span> (hexxor &gt;= <span class="number">10</span>) <span class="comment">//余数如大于等于10， 就说明应该是A-F某个数</span></span><br><span class="line">                savehex[i] = hex[hexxor - <span class="number">10</span>];<span class="comment">//获取大写字母</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                savehex[i] = hexxor + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//获取数字字符</span></span><br><span class="line">            xor = xor / <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(gps) - <span class="number">1</span>, j = <span class="number">0</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i--, j++) <span class="comment">//获取校验值</span></span><br><span class="line">            check[j] = gps[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">7</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i++) <span class="comment">//得到字段2的地址</span></span><br><span class="line">            <span class="keyword">if</span> (gps[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gps[i + <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; <span class="built_in">strcmp</span>(savehex, check) == <span class="number">0</span>) <span class="comment">//各种换算，这里有个有趣的地方，因为savehex与check的校验值都是倒着的，所以直接比较，以及时间地址是确定的</span></span><br><span class="line">        &#123;</span><br><span class="line">            *hour = (gps[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">8</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *hour = (*hour + <span class="number">8</span>) % <span class="number">24</span>;</span><br><span class="line">            *minutes = (gps[<span class="number">9</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">10</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *second = (gps[<span class="number">11</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">12</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>整体代码可为</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gettime</span><span class="params">(<span class="type">char</span> *gps, <span class="type">int</span> *hour, <span class="type">int</span> *minutes, <span class="type">int</span> *second)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hour, minutes, second;</span><br><span class="line">    <span class="type">char</span> gps[MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> end[] = <span class="string">&quot;END&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, gps);</span><br><span class="line">        gettime(gps, &amp;hour, &amp;minutes, &amp;second);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">strcmp</span>(gps, end) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d&quot;</span>, hour, minutes, second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gettime</span><span class="params">(<span class="type">char</span> *gps, <span class="type">int</span> *hour, <span class="type">int</span> *minutes, <span class="type">int</span> *second)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gps[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span> &amp;&amp; gps[<span class="number">1</span>] == <span class="string">&#x27;G&#x27;</span> &amp;&amp; gps[<span class="number">2</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; gps[<span class="number">3</span>] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; gps[<span class="number">4</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; gps[<span class="number">5</span>] == <span class="string">&#x27;C&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> hex[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> xor, hexxor, i;</span><br><span class="line">        <span class="type">char</span> savehex[MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;, check[MAX] = &#123;<span class="string">&quot;0&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        xor = gps[<span class="number">1</span>] ^ gps[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i++)</span><br><span class="line">            xor ^= gps[i];</span><br><span class="line">        xor = xor % <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; xor != <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hexxor = xor % <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span> (hexxor &gt;= <span class="number">10</span>) </span><br><span class="line">                savehex[i] = hex[hexxor - <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                savehex[i] = hexxor + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            xor = xor / <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(gps) - <span class="number">1</span>, j = <span class="number">0</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i--, j++) </span><br><span class="line">            check[j] = gps[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">7</span>; gps[i] != <span class="string">&#x27;*&#x27;</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (gps[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gps[i + <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; <span class="built_in">strcmp</span>(savehex, check) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *hour = (gps[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">8</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *hour = (*hour + <span class="number">8</span>) % <span class="number">24</span>;</span><br><span class="line">            *minutes = (gps[<span class="number">9</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">10</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *second = (gps[<span class="number">11</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + gps[<span class="number">12</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p>因为懒，博文写的太晚，现在再登陆已经暂时看不到结果，但是分数是都拿到手了<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第2章编程题-逆序的三位数</title>
    <url>/2019/07/01/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC2%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E9%80%86%E5%BA%8F%E7%9A%84%E4%B8%89%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701125528.png"></p>
<h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><p>根据提示可以简单完成大部分工作 需要注意的是700的逆序不是007，这就说明程序不能写成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="type">int</span> a = number / <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = number / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c = number % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>, c, b, a); <span class="comment">//这里简单粗暴的调换位数是不可取的，700会被逆序成007</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>用个数学式子解决: <code>c * 100 + b * 10 + a</code></p>
<p>代码可为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="type">int</span> a = number / <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = number / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> c = number % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c * <span class="number">100</span> + b * <span class="number">10</span> + a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701132954.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第3章编程题-时间换算</title>
    <url>/2019/07/01/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC3%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E6%97%B6%E9%97%B4%E6%8D%A2%E7%AE%97/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下 </p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701134832.png"></p>
<p><strong>简单解析一下</strong></p>
<p>第一眼印象是：题目真<strong>长</strong> 。其实题目没有那么复杂，它的意思是输入输出整数表示时间，而且输出是最简的，如803输出为3。要<strong>注意</strong>的是703应该输出的是2303，这也是本题所测验的地方（即提示：要注意跨日的计算），只要用个条件判断相减的数是否小于0，然后再做其他计算即可。 提取个位与十位数这两位数可以%100，提取千分位和百分位或仅提取百分位均可以&#x2F;100。 UTC与BJT相差为8，可以很容易的写出代码。 一天有24小时，且在题目中明确了有效的输入范围是0到2359，所以很明确输入输出为24小时制，我们可以知道7-8+24即为23，所以算法可以很容易的写出来。那如果没有注意跨日的计算，就会出现以下情况，大于等于8小时的结果计算正常，而小于的则异常（以我这段代码来说）<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701150903.png"></p>
<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>加一条if语句来加以约束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hour &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     hour = hour + <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701151546.png"> 可见问题已经解决，代码可为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> BJT, UTC, minute, hour;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;BJT);</span><br><span class="line">    minute = BJT % <span class="number">100</span>;</span><br><span class="line">    hour = BJT / <span class="number">100</span>;</span><br><span class="line">    hour = hour - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (hour &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hour = hour + <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UTC = hour * <span class="number">100</span> + minute;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, UTC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701151855.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第4章编程题-奇偶个数</title>
    <url>/2019/07/01/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC4%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E5%A5%87%E5%81%B6%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下</p>
<p>  <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190701153959.png"></p>
<h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><p>本题的意思是输入一些整数（-1表示结束，并不计入），读出奇数偶数分别为多少。我们知道分别奇数与偶数有个很简单的判断方法：是否能被2整除。输入是连续的，输入-1停止，而且scanf要先执行一次，说明scanf应该在循环以内（可以使用do-while；当然while也行，把一个scanf扔到外面），且循环条件为输入的数不等于-1。循环体的代码可以写成这样（大佬勿喷）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        odd++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (number != <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>当初始化even与odd为0时，我们会发现一个现象，输出结果odd总是比正确的值大1，细心一点可以发现，当输入-1时，循环又执行了一次。所以可以初始化odd为-1（大佬勿喷）</p>
<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>代码可为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number, even = <span class="number">0</span>, odd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            even++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            odd++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (number != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, odd, even);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701161338.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第5章编程题-素数和</title>
    <url>/2019/07/01/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC5%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%B4%A0%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701163507.png"></p>
<h2 id="简单分析一下胡乱分析一下"><a href="#简单分析一下胡乱分析一下" class="headerlink" title="简单分析一下胡乱分析一下"></a><del>简单分析一下</del>胡乱分析一下</h2><p>看到这题目我内心是拒绝的，因为不知道如何入手，题目中的n，m含义特殊，之间的素数也难以判断，我认为得整个素数表出来（大佬勿喷），可确实难以下手。好在我是学到第七章再回来做题的，意识到数组方面似乎可以利用，于是乎整个容量为200的数组来储存0-200个素数（建议看我这渣代码前先去看看第七章，我实在想不出啥办法了）但是问题是如何得到每一个素数呢？之前老师演示过如何判断输入的数是否为素数，相关代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> origin, i, a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;origin);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是素数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入数为origin，从2开始除，如在2到origin中，有数能够被orgin整除，则origin不为素数。那我们是否可以利用这个原理，一个个列出素数知道得到我们想要的数呢？ 答案当然是可行的。我们可以设置一个变量count，当origin为素数时加上1，如当origin的初始化为2时，count为1，在循环中，当origin加到3，count加1为2，当origin加到4，count不为所动，当origin加到5，count加1为3……以此类推，直到count&#x3D;n或m时。在这过程中，每个count对应的数都应该被记录。相关代码可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> number[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, origin = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (n != count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        number[count] = origin;</span><br><span class="line">    &#125;</span><br><span class="line">    origin++;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  值得注意的是，在这段代码中初始化a为1，这样做是为了避免程序直接从内存中抽出个0来就不好玩了。循环中的a赋值为一也十分重要，否则判断一次偶数以后，程序就死循环了，也就是n大于等于3时。对于m也相同的办法，可以copy一下（“代码复制”是程序不良的体现<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">，可以整成函数，可是好像我不会改这个） <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/IMG20190701173034.jpg"> 两段代码这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        number[count] = origin;</span><br><span class="line">    &#125;</span><br><span class="line">    origin++;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m != count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        number[count] = origin;</span><br><span class="line">    &#125;</span><br><span class="line">    origin++;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相加之间素数就简单多了，如下，从number[n]加到number[m]即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum = sum + number[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;<em>正确做法</em>&#x2F;能够跑起来的做法</strong></p>
<p>整体代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> number[<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, origin = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            number[count] = origin;</span><br><span class="line">        &#125;</span><br><span class="line">        origin++;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m != count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; origin; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (origin % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            number[count] = origin;</span><br><span class="line">        &#125;</span><br><span class="line">        origin++;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + number[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190701173942.png"></p>
<p><em>本以为内存会很大的，表现还行？</em></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第6章编程题-分解质因数</title>
    <url>/2019/07/02/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC6%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下 </p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190702140550.png"></p>
<p><strong>简单解析一下</strong></p>
<p>题目说的很明了了，废话不多说，先分析一下算法：如12除以第一个素数2得6，6除以第一个素数2得3，3为素数，即12&#x3D;2x2x3；又如15能被第二个素数3整除为5，5为素数，所以15&#x3D;3x5。我们不难发现只要一个数能被从2开始的某个素数整除，这个素数为分解质因数里的一个值，整除后的值循环反复，直到为素数时停止。 这部分代码可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">            n = n / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++; <span class="comment">//从2开始，如果2不行就加上去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现的是，质因数全部被算出来了<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190702142632.png"> 可题目要求的是输出格式为n&#x3D;axbxcxd或n&#x3D;n，我们可以在%d前面或后面加个x,但按照这个程序来说，输出结果会变成x2x2x3或2x2x3x，很显然是不正确的，所以我们可以将第一个质数单独输出，或将最后一个单独输出。这里选择后者，经过调试后，我们不难发现，最后一个质数的结果就是最后的i的值<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190702143501.png"> 经过调整，程序可以改成这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n;) <span class="comment">//为了避免重复输出，循环条件应为i&lt;n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%dx&quot;</span>, i);</span><br><span class="line">            n = n / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++; <span class="comment">//从2开始，如果2不行就加上去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这应该发现了个问题，这个程序和第六章学习的内容没有半毛钱关系，所以我们可以强行做个函数<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png"></p>
<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a><del>正确</del>做法</h2><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190702144927.png"> 代码可为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">number</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%dx&quot;</span>, i);</span><br><span class="line">            n = n / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    number(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考</strong></p>
<p>发现程序更啰嗦了，或许我们可以整个头文件，眼不见为净<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">，如图，建立个.h的文件<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/TIM%E6%88%AA%E5%9B%BE20190702145345.png"> 然后直接引用这个头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decomposition-factor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    number(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，对于引用自己的头文件，include后面应该用””而不是&lt;&gt;</p>
<p><strong>PS</strong></p>
<p>这个程序我写了两次，第一次真是又臭又长，不介意的话可以吐口痰再走</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> x, z = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = n;</span><br><span class="line">            n = n / i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">2</span>; m &lt; x; m++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % m == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    z = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%dx&quot;</span>, i);</span><br><span class="line">                z = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写的什么玩意儿！</strong></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第7章编程题-多项式加法</title>
    <url>/2019/08/02/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC7%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190802095458.png"></p>
<h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><p>题目要求输入的数合并同类项后按照幂次大小排序，这里值得注意的是，如系数或幂次为1都应该省略；当输入为0 0，0 0时，输出0；可以有负数输入；了解了这些细节以后，就该考虑怎么做了。 我首先想到的是用二维数组存数据，结果写了600多行依然没解决（没考虑到可以有负数输入），只能另想办法。最后我发现可以利用数组的[]来储存幂次，值来存系数，这样工作量大大减少，故开始部分可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> number[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//题目说处理最大的幂为100，加上0即是最大量为101；初始化为0</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//输入两组数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, j;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;j, &amp;sum);</span><br><span class="line">        <span class="keyword">if</span> (j &gt; cnt)</span><br><span class="line">            cnt = j; <span class="comment">//记录输入的最大幂次</span></span><br><span class="line">        number[j] += sum; <span class="comment">//相同幂次的值相加</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (j &gt; <span class="number">0</span>); <span class="comment">//输入0停止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cnt; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (number[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max = i; <span class="comment">//记录有效的最大幂次，因为&#x27;某个幂次的系数为0，就不出现在输入数据中&#x27;不代表我不能输入如 6 2， 6 -2;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我们创建了大小为101的数组，每个量都被初始化为0，即系数为零，所以我们应该跳过输出这些量；还要判断当输入的值都是 0 0的情况；判断为系数为1的情况；判断幂次为1的情况；判断幂次为0的情况；判断系数与幂次都为1的情况。种种情况考虑到的话，可以写出如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = max; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (number[i] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, number[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;+%d&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (i == max)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;+x&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (number[i] == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%dx&quot;</span>, number[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+%dx&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (i == max)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x%d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;+x%d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (number[i] == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-x%d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%dx%d&quot;</span>, number[i], i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+%dx%d&quot;</span>, number[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>整体代码可为</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum, j;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;j, &amp;sum);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; cnt)</span><br><span class="line">                cnt = j;</span><br><span class="line">            number[j] += sum;</span><br><span class="line">        &#125; <span class="keyword">while</span> (j &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (max == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, number[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;+%d&quot;</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (i == max)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;+x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (number[i] == <span class="number">-1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;-x&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%dx&quot;</span>, number[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;+%dx&quot;</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (i == max)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;x%d&quot;</span>, i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;+x%d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == max  number[i] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (number[i] == <span class="number">-1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;-x%d&quot;</span>, i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%dx%d&quot;</span>, number[i], i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;+%dx%d&quot;</span>, number[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190802125031.png"> <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190802125131.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C语言程序设计CAP-第8章编程题-计算分数精确值</title>
    <url>/2019/08/19/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1cap-%E7%AC%AC8%E7%AB%A0%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%AE%A1%E7%AE%97%E5%88%86%E6%95%B0%E7%B2%BE%E7%A1%AE%E5%80%BC/</url>
    <content><![CDATA[<p><em>即将上大学了，准备上一些先修课，<a class="link"   href="https://www.icourse163.org/u/wengkai" >翁恺老师<i class="fas fa-external-link-alt"></i></a>的课感觉非常不错，我是一个初学者，有啥错误大佬们别打我。</em></p>
<p>依照学术诚信条款，我保证此作业是本人独立完成的，未完成该项作业的同学请完成后再来。</p>
<p>此编程题的题目如下</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190819164000.png">  </p>
<h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><p>题目看起来很长，但是读完后发现问题不大，按照题目要求，较容易写出程序，值得注意的是，输出时要换行</p>
<p><strong>整体代码可为</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) <span class="comment">//最多200位</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a * <span class="number">10</span> / b;</span><br><span class="line">        a = a * <span class="number">10</span> % b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;n&quot;</span>); <span class="comment">//换行</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//余数等于0时退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">199</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p>因为懒，博文写的太晚，现在再登陆已经暂时看不到结果，但是分数是都拿到手了<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>eHallTools-天津理工大学网上办事大厅工具</title>
    <url>/2019/11/29/ehalltools-%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BE%BF%E5%88%A9%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="1-8-5"><a href="#1-8-5" class="headerlink" title="1.8.5"></a>1.8.5</h3><ul>
<li>20200103更新</li>
<li>选课结果查看</li>
<li>添加关于软件</li>
</ul>
<h3 id="1-8-0"><a href="#1-8-0" class="headerlink" title="1.8.0"></a>1.8.0</h3><ul>
<li>20191231更新</li>
<li>添加当前登录功能</li>
</ul>
<h3 id="1-7-5"><a href="#1-7-5" class="headerlink" title="1.7.5"></a>1.7.5</h3><ul>
<li>20191231更新</li>
<li>使用XPath提取HTML数据</li>
<li>修复Bug</li>
</ul>
<h3 id="1-7-0"><a href="#1-7-0" class="headerlink" title="1.7.0"></a>1.7.0</h3><ul>
<li>20191230更新</li>
</ul>
<h2 id="使用前必看"><a href="#使用前必看" class="headerlink" title="使用前必看"></a>使用前必看</h2><ul>
<li>软件采用.Net Core WPF开发, 需下载安装运行时才能正常运行<a class="link"   href="https://dotnet.microsoft.com/download" >.Net Core Runtime<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="什么是eHallTools"><a href="#什么是eHallTools" class="headerlink" title="什么是eHallTools?"></a>什么是eHallTools?</h2><ul>
<li>一个小软件，用于方便的查看大学eHall网站上的信息，针对天津理工大学eHall进行的开发，由于不知道其他学校eHall有没有通知公告等功能，故不一定通用</li>
</ul>
<h2 id="为什么开发它"><a href="#为什么开发它" class="headerlink" title="为什么开发它"></a>为什么开发它</h2><ul>
<li>初学C#，想写一些项目学习并巩固知识</li>
</ul>
<h2 id="软件功能"><a href="#软件功能" class="headerlink" title="软件功能"></a>软件功能</h2><ul>
<li>通知公告</li>
<li>师生服务（实现考试安排查询, 成绩查询, 选课结果查看）</li>
<li>当前登录</li>
</ul>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul>
<li>登录界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129224021.png" alt="登录界面"></li>
</ul>
<p>学校服务地址配置存储格式，可编辑添加（&#x2F;config&#x2F;server.json）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Info&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;University&quot;</span>: <span class="string">&quot;天津理工大学&quot;</span>,</span><br><span class="line">      <span class="string">&quot;AuthserverHttp&quot;</span>: <span class="string">&quot;http://authserver.tjut.edu.cn&quot;</span>,</span><br><span class="line">      <span class="string">&quot;EhallHttp&quot;</span>: <span class="string">&quot;http://ehall.tjut.edu.cn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在页面添加 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129225250.png" alt="添加服务界面"> 或删除 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129230058.png" alt="删除服务界面"> 账号密码等信息的保存（&#x2F;config&#x2F;settings.json）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;RememberPassword&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;AutoLogin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;SelectedUniversityIndex&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;StudentId&quot;</span>: <span class="string">&quot;11111&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Password&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用选择"><a href="#应用选择" class="headerlink" title="应用选择"></a>应用选择</h3><ul>
<li>应用选择界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129230229.png" alt="应用选择界面"></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="通知公告"><a href="#通知公告" class="headerlink" title="通知公告"></a>通知公告</h3><ul>
<li><p>界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130925.png" alt="通知公告"></p>
</li>
<li><p>双击看详情，如有文件，双击下载（&#x2F;downloads&#x2F;标题） <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130835.png" alt="详情"></p>
</li>
<li><p>输入进行搜索 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130802.png" alt="搜索"></p>
</li>
</ul>
<h3 id="考试安排查询"><a href="#考试安排查询" class="headerlink" title="考试安排查询"></a>考试安排查询</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130655.png" alt="考试安排查询"></p>
<h3 id="成绩查询"><a href="#成绩查询" class="headerlink" title="成绩查询"></a>成绩查询</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130715.png" alt="成绩查询"></p>
<h3 id="选课结果查看"><a href="#选课结果查看" class="headerlink" title="选课结果查看"></a>选课结果查看</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20200103211502.png" alt="选课结果查看"></p>
<h3 id="当前登录"><a href="#当前登录" class="headerlink" title="当前登录"></a>当前登录</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191231223602.png" alt="当前登录"></p>
<ul>
<li>双击踢出设备</li>
<li>一键踢出所有设备</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>对于某些通知，处理的并不好（没法看）如以下通知，因技术有限，处理成一坨, 如需查看，双击通知内容进入浏览器解析 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129231746.png" alt="案例"></p>
</li>
<li><p>并不需要连接校园网，但是校园网访问很快！</p>
</li>
<li><p>添加删除服务地址后，回主页面更新即可</p>
</li>
<li><p>电信用户使用可能使用不太顺畅，这是没办法的事，原因是电信绕路 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230131933.png" alt="辣鸡电信"></p>
</li>
</ul>
<h2 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h2><ul>
<li><a class="link"   href="https://github.com/Spxg/eHallTools/releases/download/v1.8.5/eHallTools.zip" >eHallTools<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a class="link"   href="https://github.com/Spxg/eHallTools" >eHallToolsSource<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul>
<li><a class="link"   href="https://github.com/itswait" >Wait<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>C Sharp</category>
      </categories>
  </entry>
  <entry>
    <title>FAT32 FileSystem Library</title>
    <url>/2020/10/16/fat32-filesystem-library/</url>
    <content><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a class="link"   href="https://github.com/Spxg/fat32" >Github<i class="fas fa-external-link-alt"></i></a></h1><p><a href="https://crates.io/crates/fat32"><img src="https://img.shields.io/crates/v/fat32.svg" alt="crates.io version"></a> This is FAT32 FileSystem Library, which is <code>#![no_std]</code> and does not use <code>alloc</code>. Test passed with <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> and WindowsAPI.</p>
<h2 id="Supported-Features"><a href="#Supported-Features" class="headerlink" title="Supported Features"></a>Supported Features</h2><ul>
<li>[x] Read</li>
<li>[x] Create File AND Dir</li>
<li>[x] Write(OverWritten and Append)</li>
<li>[x] Delete File AND DIR</li>
</ul>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="My-Device-Support-std-Can-I-Use-This-Crate"><a href="#My-Device-Support-std-Can-I-Use-This-Crate" class="headerlink" title="My Device Support std, Can I Use This Crate?"></a>My Device Support <code>std</code>, Can I Use This Crate?</h3><p>Of course you can, but I don’t recommend it. You should use <code>std::fs::File</code> OR other crates.</p>
<h3 id="Why-Do-You-Write-This-Crate"><a href="#Why-Do-You-Write-This-Crate" class="headerlink" title="Why Do You Write This Crate?"></a>Why Do You Write This Crate?</h3><p>In order to support devices and environment which don’t have <code>std</code>, like * Embedded Device * Bootloader</p>
<h3 id="Have-More-Examples"><a href="#Have-More-Examples" class="headerlink" title="Have More Examples?"></a>Have More Examples?</h3><ul>
<li><a class="link"   href="https://github.com/play-stm32/bootloader" >Embedded Device’s Bootloader<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="How-To-Test-Only-Windows"><a href="#How-To-Test-Only-Windows" class="headerlink" title="How To Test (Only Windows)"></a>How To Test (Only Windows)</h2><ul>
<li>EDIT mount() function in lib.rs, change disk like <code>\\\\.\\E:</code></li>
<li><code>cargo test</code></li>
</ul>
<h2 id="How-To-Use"><a href="#How-To-Use" class="headerlink" title="How To Use"></a>How To Use</h2><p>You need make your library implement <a href="https://github.com/Spxg/block_device"><code>BlockDevice</code> trait</a>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BlockDevice</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example, I use my another library <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> to implement:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">BlockDevice</span> <span class="keyword">for</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = CmdError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> number_of_blocks == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">read_block</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">read_multi_blocks</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>, number_of_blocks <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> number_of_blocks == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">write_block</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">write_multi_blocks</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>, number_of_blocks <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> library supported fat32 filesystem. Then, add fat32 library to your application</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># if no feature config, the BUFFER_SIZE is 512 Bytes</span><br><span class="line">fat32 = &quot;0.2&quot;</span><br></pre></td></tr></table></figure>

<p>If your card block is other size, like 1024 Bytes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dependencies.fat32]</span><br><span class="line">version = &quot;0.2&quot;</span><br><span class="line">default-features = false</span><br><span class="line">features = [&quot;1024&quot;]</span><br></pre></td></tr></table></figure>

<p>Then, you can do some tests</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Card from sdio_sdhc crate</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">card</span> = Card::<span class="title function_ invoke__">init</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// Volume from fat32 crate</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cont</span> = Volume::<span class="title function_ invoke__">new</span>(card);</span><br><span class="line"><span class="comment">// cd root dir</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">root</span> = cont.<span class="title function_ invoke__">root_dir</span>();</span><br><span class="line"><span class="comment">// create file named test.txt</span></span><br><span class="line">root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;test.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = root.<span class="title function_ invoke__">open_file</span>(<span class="string">&quot;test.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// write buffer to file</span></span><br><span class="line">file.<span class="title function_ invoke__">write</span>(&amp;[<span class="number">80</span>; <span class="number">1234</span>]).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>If all goes well, the file was created with 1234 Bytes in root dir.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>GPS数据处理-C#版</title>
    <url>/2019/10/05/gps%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-c-sharp%E7%89%88/</url>
    <content><![CDATA[<p><em>C版本见这</em></p>
<p><a href="https://unsafe.me/archives/567">C语言程序设计CAP-第10章编程题-GPS数据处理</a></p>
<p>国庆总得给自己找点事做，不打游戏，不想做作业，还能干啥?</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Gps gps = <span class="keyword">new</span> Gps();</span><br><span class="line">            <span class="built_in">string</span> hour = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> minute = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> second = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">            str = Convert.ToString(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!str.Equals(<span class="string">&quot;END&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (gps.CheckHeader(str) &amp;&amp; gps.CheckNum(str) &amp;&amp; gps.CheakLocated(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    hour = gps.GetHour(str);</span><br><span class="line">                    minute = gps.GetMinute(str);</span><br><span class="line">                    second = gps.GetSecond(str);</span><br><span class="line">                &#125;</span><br><span class="line">                str = Convert.ToString(Console.ReadLine());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(hour + <span class="string">&quot;:&quot;</span> + minute + <span class="string">&quot;:&quot;</span> + second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Gps</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckHeader</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str.Substring(<span class="number">0</span>, <span class="number">6</span>).Equals(<span class="string">&quot;$GPRMC&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckNum</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对比C版，对异或值的计算更合理。</span></span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line">            <span class="built_in">int</span> xornum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; str[i] != <span class="string">&#x27;*&#x27;</span>; i++)</span><br><span class="line">                xornum ^= str[i];</span><br><span class="line">            xornum %= <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Convert.ToString(xornum, <span class="number">16</span>).Equals(str.Substring(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheakLocated</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">7</span>; str[i] != <span class="string">&#x27;,&#x27;</span>; i++)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> str[i + <span class="number">1</span>].Equals(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetHour</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> hour = (str[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">8</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            hour = (hour + <span class="number">8</span>) % <span class="number">24</span>;</span><br><span class="line">            <span class="keyword">return</span> hour.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetMinute</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> minute = (str[<span class="number">9</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">10</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> minute.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetSecond</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> second = (str[<span class="number">11</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">12</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> second.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C Sharp</category>
      </categories>
  </entry>
  <entry>
    <title>Rust 宏(Macro)</title>
    <url>/2021/01/16/rust-%E5%AE%8Fmacro/</url>
    <content><![CDATA[<h2 id="Rust-宏-Macro"><a href="#Rust-宏-Macro" class="headerlink" title="Rust 宏(Macro)"></a>Rust 宏(Macro)</h2><p>​ 众所周知, <em>Rust_提供了一个强大的宏系统，可进行元编程(metaprogramming)。_Rust</em> 中的宏几乎无处不在，其实你们写的第一个_Rust_ 程序里面就已经用到了宏，比如<code>println!</code>，宏看起来和函数很像，只不过名称末尾有一个感叹号 <code>!</code> 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。 ​ 由于才疏学浅，不敢班门弄斧，所以主要从例子出发，不深究原理，文章适合有_Rust_基础的同学看，官方文档 <a class="link"   href="https://doc.rust-lang.org/book/ch19-06-macros.html" >The Rust Programming Language<i class="fas fa-external-link-alt"></i></a> ​ 我的Github: <a class="link"   href="https://github.com/Spxg" >上铺小哥Spxg<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="与C的宏有什么不同"><a href="#与C的宏有什么不同" class="headerlink" title="与C的宏有什么不同"></a>与C的宏有什么不同</h3><p>_C_的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">define ONE_PLUE_ONE <span class="number">2</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ONE_PLUS_ONE);</span><br></pre></td></tr></table></figure>

<p>_Rust_的宏：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> ONE_PLUS_ONE &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ONE_PLUS_ONE!());</span><br></pre></td></tr></table></figure>

<p>可能有同学要问了，_Rust_的宏与_C_的相比有什么不同。不同的是，_Rust_的宏会展开为抽象语法树(AST，abstract syntax tree)，而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。</p>
<h3 id="动手整个map"><a href="#动手整个map" class="headerlink" title="动手整个map!"></a>动手整个map!</h3><p>了解_Rust_的同学，相比对<code>vec!</code>不陌生，<code>vec![1, 2, 3]</code>相当于</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>可见宏使用可以带来便捷，那我们可不可以为_HashMap_实现相似的功能呢，当然可以，考虑下面几行代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     &quot;me&quot; =&gt; &quot;laji&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;you&quot; =&gt; &quot;good&quot;  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;me&quot;</span>, <span class="string">&quot;laji&quot;</span>);</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;you&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们不妨设计成_key_ &#x3D;&gt; _value_的模式，像Ruby一样，将其插入到一个Map中，如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">marco_rule! map &#123;</span><br><span class="line">    <span class="comment">// $(...), + will be expanded for each matches </span></span><br><span class="line">    <span class="comment">// Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x</span></span><br><span class="line">    ($($key: expr =&gt; $value: expr), +) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        $(map.<span class="title function_ invoke__">insert</span>($key, $value);), +</span><br><span class="line">        map</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用map!来生成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">map</span> = map!(</span><br><span class="line">    <span class="string">&quot;me&quot;</span> =&gt; <span class="string">&quot;laji&quot;</span>,</span><br><span class="line">    <span class="string">&quot;you&quot;</span> =&gt; <span class="string">&quot;good&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>不难发现，其精髓还是对号入座，可以在脑子里替换进去</p>
<h3 id="玩个大点的"><a href="#玩个大点的" class="headerlink" title="玩个大点的"></a>玩个大点的</h3><p>同学们都知道<code>fibonacci</code>数，我们都知道这列值可以永远持续下去，定义一个<code>fibonacci</code>的求值函数略显困难。显然，返回一整列值并不实际。我们真正需要的，应是某种具有惰性求值性质的东西——只在必要的时候才进行运算求值。 在Rust中，这样的需求表明，是<code>Iterator</code>派上用场的时候了。实现迭代器并不十分困难，但比较繁琐：你得自定义一个类型，弄明白该在其中存储什么，然后为它实现<code>Iterator</code> trait。 其实，递推关系足够简单；几乎所有的递推关系都可被抽象出来，变成一小段由宏驱动的代码生成机制。 但是我们不写<code>fibonacci</code>，写了就有点大材小用<del>脱裤子放屁</del>了，就为了一个<code>fibonacci</code>写宏多不值啊，编译器展开和自己写还不是一样。所以，我们整个比较通用的。</p>
<h4 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h4><p>同学们都是学过来的，想必都遇到过这些东西： <code>a = 1, 2, ..., n</code> <code>a = 1.0, ..., n * a[n - 1]</code> <code>fib = 0, 1, ..., fib[n - 1] + fib[n - 2]</code> 我们通过自己设计的宏假装实现一下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">recurrence!(a[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... n);</span><br><span class="line">recurrence!(a[n]: <span class="type">f64</span> = <span class="number">1.0</span> ... n * a[n - <span class="number">1</span>]);</span><br><span class="line">recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="列出方程"><a href="#列出方程" class="headerlink" title="列出方程"></a>列出方程</h4><p>以<code>fibonacci</code>为例， <code>fib[0] = 0</code> <code>fib[1] = 1</code> <code>fib[2] = fib[2 - 1] + fib[2 - 2] = 1</code> <code>fib[3] = fib[3 - 1] + fib[3 - 2] = 2</code> <code>......</code> 可以知道，我们只要有两个初始值就可以通过迭代算出任意一个<code>fibonacci</code>数，所以只需定义一个数组，列出方程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pseudocode</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">fib</span> = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = fib.<span class="title function_ invoke__">length</span>();</span><br><span class="line"><span class="keyword">if</span> n &lt; length &#123;</span><br><span class="line">    fib[n]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// offset is the times of iter</span></span><br><span class="line">    fib[n - <span class="number">1</span> - offset + length] + fib[n - <span class="number">2</span> - offset + length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计程序"><a href="#设计程序" class="headerlink" title="设计程序"></a>设计程序</h4><p>有了方程后，我们开始做更细化的操作，解决问题，如<code>fib[n - offset + length]</code>。有的同学就要问了：这有啥问题，不是很符合逻辑吗？的确很符合，但是有大坑啊，<code>n - 2 - offset</code> 在<code>n</code>为2开始的时候程序就panic了。原因是：在_Rust_中， 数组的Index是<code>usize</code>类型，必是大于等于0，<code>n</code>为2开始，其中间运算小于0，直接爆炸，所以我们需要改改逻辑：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">1</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">2</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">fib[a <span class="keyword">as</span> <span class="type">usize</span>] + fib[b <span class="keyword">as</span> <span class="type">usize</span>];</span><br></pre></td></tr></table></figure>

<p>看了以后，可能有些同学觉得这<del>尼玛是啥</del>太复杂了，很不美观，所以我们再想想。在_Rust_中，有个<code>std::num::Wrapping</code>类型，它就是干这事的，话不多说，看代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Provides intentionally-wrapped arithmetic on T.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations like + on u32 values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrapping arithmetic can be achieved either through methods like wrapping_add, or through the Wrapping&lt;T&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The underlying value can be retrieved through the .0 index of the Wrapping tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Wrapping</span>(n);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(offset);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = <span class="title function_ invoke__">Wrapping</span>(length);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">real_index</span> = n - offset + length;</span><br><span class="line">fib[real_index.<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>总算比上面一坨好看多了。</p>
<h4 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h4><p><em>Rust</em> 提供了Iterator trait，使我们更好使用，而且还有好多实现了Iterator类型的方法，用它就完了，trait 长这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span></span><br><span class="line"><span class="comment">//  The type of the elements being iterated over.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Required methods</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"><span class="comment">//  Advances the iterator and returns the next value.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns None when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling next() again may or may not eventually start returning Some(Item) again at some point.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在_Rust_中，<code>[]</code>操作来源于<code>Index&lt;T&gt;</code> trait, 其中的<code>T</code>就是Index的类型，在这里就是<code>usize</code>，<code>Index&lt;T&gt;</code> trait 长这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Index</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: ?<span class="built_in">Sized</span></span><br><span class="line">    <span class="comment">// The returned type after indexing.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required methods</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Output</span><br><span class="line">    <span class="comment">// Performs the indexing (container[index]) operation.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接开始写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Index;</span><br><span class="line"><span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    mem: [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    pos: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            mem: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            pos: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    slice: &amp;<span class="symbol">&#x27;a</span> [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">        &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="keyword">self</span>.pos;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fib</span> = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset &#125;;</span><br><span class="line">                fib[offset - <span class="number">1</span>] + fib[offset - <span class="number">2</span>]</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// move forward</span></span><br><span class="line">                <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fib</span> = Solution::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter 10 times</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">f</span> <span class="keyword">in</span> fib.<span class="title function_ invoke__">take</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行一把梭，轻松秒杀：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>有了这个经验，写宏就很简单了，首先要解决的是，怎么让宏知道你初始有几个元素？套娃就对了！直接上代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        $recur</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们测试一波：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] * fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error: `$inits:expr` may be followed by `...`, which is not allowed <span class="keyword">for</span> `expr` fragments</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">8</span>:<span class="number">62</span></span><br><span class="line">  </span><br><span class="line"><span class="number">8</span>      ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">                                                                ^^^ not allowed after `expr` fragments</span><br><span class="line">  </span><br><span class="line">  = note: allowed there are: `=&gt;`, `,` or `;`</span><br></pre></td></tr></table></figure>

<p>看来是不能用<code>...</code>了，那我们换成<code>=&gt;</code></p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + =&gt; $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        ($recur)</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = recurrence!(s1[n]: <span class="type">usize</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; n);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1.take(6) is&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = recurrence!(s2[n]: <span class="type">f64</span> = <span class="number">1.0</span> =&gt; s2[n - <span class="number">1</span>] * n <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>).<span class="title function_ invoke__">fold</span>(<span class="number">0.0</span>, acc, x acc + x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2.take(3)&#x27;s sum is &#123;&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = recurrence!(s3[n]: <span class="type">usize</span> = <span class="number">1</span> =&gt; n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3.take(5) is &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fib</span> = recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sixth</span> = fib.<span class="title function_ invoke__">nth</span>(<span class="number">6</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the sixth of fibonacci is &#123;&#125;&quot;</span>, sixth);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;RUST NB!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) is</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-------------</span><br><span class="line">s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>)<span class="symbol">&#x27;s</span> sum is <span class="number">4</span></span><br><span class="line">-------------</span><br><span class="line">s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>) is [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">-------------</span><br><span class="line">the sixth of fibonacci is <span class="number">8</span></span><br><span class="line">-------------</span><br><span class="line">RUST NB!</span><br></pre></td></tr></table></figure>

<h3 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h3><ul>
<li><p><a class="link"   href="https://danielkeep.github.io/tlborm/" >The Little Book of Rust Macros<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://doc.rust-lang.org/book/title-page.html" >The Rust Programming Language<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust生命周期学习</title>
    <url>/2021/01/31/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="生命周期学习"><a href="#生命周期学习" class="headerlink" title="生命周期学习"></a>生命周期学习</h2><h3 id="出个题目："><a href="#出个题目：" class="headerlink" title="出个题目："></a>出个题目：</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NumRef</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">change</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, num: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> = num;</span><br><span class="line">        *<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_ref</span> = <span class="title function_ invoke__">NumRef</span>(&amp;<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题一：<em>以上代码编译是否会出错,为什么?如果会出错,怎么修改让它不出错？</em></li>
<li>问题二： <em>假如你已经解决了第一题，那代码这么写的会有什么局限性?</em> </li>
<li>问题三：<em>添加一行代码，证明第二题你所认为的局限性</em></li>
<li>问题四：<em>按照第二题你所认为的局限性,修改代码,消除局限性</em></li>
<li>问题五：<em>本题你学到了什么</em></li>
</ul>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ul>
<li><p>一，CV一把梭，就知道能编译过去了，所以答案是不会出错。</p>
</li>
<li><p>二，根据生命周期分析，<code>NumRef</code>和<code>change</code>方法中的<code>self</code>(注：<code>&amp;&#39;a mut self</code>是<code>self: &amp;&#39;a mut Self</code> 的简写)标记的生命周期都是<code>&#39;a</code>，可以理解为这个可变引用的生命周期和结构体的生命周期一样长，根据可变引用的独占性，<code>num_ref</code>一但调用<code>change</code>方法，之后其任何引用的使用都会触发借用检查的报错，所以局限性在于只能调用一次<code>change</code>方法(这样的应用很少)</p>
</li>
<li><p>三，添加<code>let _ = num_ref.change(&amp;7);</code>  触发报错：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow `num_ref` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">   |             ------- first mutable borrow occurs here</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">_</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">7</span>);</span><br><span class="line">   |             ^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             second mutable borrow occurs here</span><br><span class="line">   |             first borrow later used here</span><br></pre></td></tr></table></figure>

<p>添加<code> println!(&quot;&#123;:?&#125;&quot;, num_ref);</code>   触发报错(<code>println!</code>使用了引用)：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0502]: cannot borrow `num_ref` <span class="keyword">as</span> immutable because it is also borrowed <span class="keyword">as</span> mutable</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">15</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">   |             ------- mutable borrow occurs here</span><br><span class="line"><span class="number">14</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num_ref);</span><br><span class="line">   |                      ^^^^^^^</span><br><span class="line">   |                      |</span><br><span class="line">   |                      immutable borrow occurs here</span><br><span class="line">   |                      mutable borrow later used here</span><br></pre></td></tr></table></figure>

<ul>
<li>四，删掉<code>&amp;&#39;a mut self</code>中的<code>&#39;a</code>即可</li>
<li>五，别瞎写生命周期参数</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>T and &#39;static</title>
    <url>/2021/01/24/t-static/</url>
    <content><![CDATA[<h1 id="T-‘static"><a href="#T-‘static" class="headerlink" title="T: ‘static"></a>T: ‘static</h1><h2 id="先看几个误区-直接摘抄自Rust生命周期常见误区"><a href="#先看几个误区-直接摘抄自Rust生命周期常见误区" class="headerlink" title="先看几个误区(直接摘抄自Rust生命周期常见误区)"></a>先看几个误区(直接摘抄自<a class="link"   href="https://github.com/whfuyn/rust-blog/blob/master/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3.md" >Rust生命周期常见误区<i class="fas fa-external-link-alt"></i></a>)</h2><h3 id="1-T-只包含所有权类型"><a href="#1-T-只包含所有权类型" class="headerlink" title="1) T 只包含所有权类型"></a>1) <code>T</code> 只包含所有权类型</h3><p>这个误解比起说生命周期，它和泛型更相关，但在Rust中泛型和生命周期是紧密联系在一起的，不可只谈其一。</p>
<p>当我刚开始学习Rust的时候，我理解<code>i32</code>，<code>&amp;i32</code>，和<code>&amp;mut i32</code>是不同的类型，也明白泛型变量<code>T</code>代表着所有可能类型的集合。<br>但尽管这二者分开都懂，当它们结合在一起的时候我却陷入困惑。在我这个Rust初学者的眼中，泛型是这样的运作的：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型变量</strong></td>
<td><code>T</code></td>
<td><code>&amp;T</code></td>
<td><code>&amp;mut T</code></td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>i32</code></td>
<td><code>&amp;i32</code></td>
<td><code>&amp;mut i32</code></td>
</tr>
</tbody></table>
<p><code>T</code> 包含一切所有权类型； <code>&amp;T</code> 包含一切不可变借用类型； <code>&amp;mut T</code> 包含一切可变借用类型。<br><code>T</code>， <code>&amp;T</code>， 和 <code>&amp;mut T</code> 是不相交的有限集。 简洁明了，符合直觉，但却完全错误。<br>下面这才是泛型真正的运作方式：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型变量</strong></td>
<td><code>T</code></td>
<td><code>&amp;T</code></td>
<td><code>&amp;mut T</code></td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>i32</code>, <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code>, …</td>
<td><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code>, …</td>
<td><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code>, …</td>
</tr>
</tbody></table>
<p><code>T</code>, <code>&amp;T</code>, 和 <code>&amp;mut T</code> 都是无限集, 因为你可以无限借用一个类型。<br><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code>的超集. <code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合。<br>让我们用几个例子来检验一下这些概念:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码并不能如愿编译:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0119]: conflicting implementations of <span class="keyword">trait</span> `Trait` <span class="keyword">for</span> <span class="title class_">type</span> `&amp;_`:</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">5</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation <span class="keyword">for</span> `&amp;_`</span><br><span class="line"></span><br><span class="line">error[E0119]: conflicting implementations of <span class="keyword">trait</span> `Trait` <span class="keyword">for</span> <span class="title class_">type</span> `&amp;<span class="keyword">mut</span> _`:</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">7</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line">...</span><br><span class="line"><span class="number">7</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation <span class="keyword">for</span> `&amp;<span class="keyword">mut</span> _`</span><br></pre></td></tr></table></figure>

<p>编译器不允许我们为<code>&amp;T</code>和<code>&amp;mut T</code>实现<code>Trait</code>，因为这样会与为<code>T</code>实现的<code>Trait</code>冲突，<br><code>T</code>本身已经包含了所有<code>&amp;T</code>和<code>&amp;mut T</code>。下面的代码能够如愿编译，因为<code>&amp;T</code>和<code>&amp;mut T</code>是不相交的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125; <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<p><strong>要点</strong></p>
<ul>
<li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code>的超集</li>
<li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li>
</ul>
<h3 id="2-如果-T-39-static-那么-T-必须在整个程序运行中都是有效的"><a href="#2-如果-T-39-static-那么-T-必须在整个程序运行中都是有效的" class="headerlink" title="2) 如果 T: &#39;static 那么 T 必须在整个程序运行中都是有效的"></a>2) 如果 <code>T: &#39;static</code> 那么 <code>T</code> 必须在整个程序运行中都是有效的</h3><p><strong>误解推论</strong></p>
<ul>
<li><code>T: &#39;static</code> 应该被看作 <em>“ <code>T</code> 拥有 <code>&#39;static</code> 生命周期 “</em></li>
<li><code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 没有区别</li>
<li>如果 <code>T: &#39;static</code> 那么 <code>T</code> 必须为不可变的</li>
<li>如果 <code>T: &#39;static</code> 那么 <code>T</code> 只能在编译期创建</li>
</ul>
<p>大部分Rust初学者是从类似下面这个代码示例中接触到 <code>&#39;static</code> 生命周期的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他们被告知 <code>&quot;str literal&quot;</code> 是硬编码在编译出来的二进制文件中的，<br>并会在运行时被加载到只读内存，所以必须是不可变的且在整个程序的运行中都是有效的，<br>这就是它成为 <code>&#39;static</code> 的原因。<br>而这些观念又进一步被用 <code>static</code> 关键字来定义静态变量的规则所加强。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 编译错误，修改静态变量是unsafe的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>认为静态变量</p>
<ul>
<li>只可以在编译期创建</li>
<li>必须是不可变的，修改它们是unsafe的</li>
<li>在整个程序的运行过程中都是有效的</li>
</ul>
<p><code>&#39;static</code> 生命周期大概是以静态变量的默认生命周期命名的，对吧？<br>那么有理由认为<code>&#39;static</code>生命周期也应该遵守相同的规则，不是吗？</p>
<p>是的，但拥有<code>&#39;static</code>生命周期的类型与<code>&#39;static</code>约束的类型是不同的。<br>后者能在运行时动态分配，可以安全地、自由地修改，可以被drop，<br>还可以有任意长度的生命周期。</p>
<p>在这个点，很重要的是要区分 <code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code>。</p>
<p><code>&amp;&#39;static T</code>是对某个<code>T</code>的不可变引用，这个引用可以被无限期地持有直到程序结束。<br>这只可能发生在<code>T</code>本身不可变且不会在引用被创建后移动的情况下。<br><code>T</code>并不需要在编译期就被创建，因为我们可以在运行时动态生成随机数据，<br>然后以内存泄漏为代价返回<code>&#39;static</code>引用，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时生成随机&amp;&#x27;static str</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    Box::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>T: &#39;static</code> 是指<code>T</code>可以被无限期安全地持有直到程序结束。<br><code>T: &#39;static</code>包括所有<code>&amp;&#39;static T</code>，此外还包括所有的所有权类型，比如<code>String</code>, <code>Vec</code>等。<br>数据的所有者能够保证数据只要还被持有就不会失效，因此所有者可以无限期安全地持有该数据直到程序结束。<br><code>T: &#39;static</code>应该被看作“<code>T</code>受<code>&#39;static</code>生命周期约束”而非“<code>T</code>有着<code>&#39;static</code>生命周期”。<br>这段代码能帮我们阐释这些概念：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// 所有字符串都是随机生成的</span></span><br><span class="line">            <span class="comment">// 并且是在运行时动态申请的</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些字符串都是所有权类型，所以它们满足&#x27;static约束</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// 这些字符串都是可以修改的</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// 这些字符串都是可以被drop的</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// 编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这些字符串都在程序结束之前失效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要点</strong></p>
<ul>
<li><code>T: &#39;static</code> 应该被看作 <em><code>T</code>受<code>&#39;static</code>生命周期约束”</em></li>
<li>如果 <code>T: &#39;static</code> 那么<code>T</code>可以是有着<code>&#39;static</code>生命周期的借用类型</li>
<li>由于 <code>T: &#39;static</code> 包括了所有权类型，这意味着<code>T</code><ul>
<li>可以在运行时动态分配</li>
<li>不一定要在整个程序的运行过程中都有效</li>
<li>可以被安全地、自由地修改</li>
<li>可以在运行时被动态drop掉</li>
<li>可以有不同长度的生命周期</li>
</ul>
</li>
</ul>
<h2 id="我对T-’static的认识"><a href="#我对T-’static的认识" class="headerlink" title="我对T: ’static的认识"></a>我对T: ’static的认识</h2><p>上文中提到了对<code>T</code>， <code>&amp;T</code>， <code>&amp;mut T</code>和<code>&amp;&#39;static T</code>，<code>T: &#39;static</code>的误区，其中有这么一句话：*<code>T: &#39;static</code>包括所有<code>&amp;&#39;static T</code>，此外还包括所有的所有权类型，比如<code>String</code>, <code>Vec</code>等。* 所有权类型可以理解成不包含引用的类型，我们来试试是不是这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_str</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;t: &#x27;static test&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(s_str);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，编译通过了，<code>s_str</code>是<code>&amp;&#39;static</code>类型，<code>box_i32</code>是所有权类型。接下来我们稍微改改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(&amp;box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[E0597]: `box_i32` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:9:17</span><br><span class="line">   |</span><br><span class="line">9  |     static_test(&amp;box_i32);</span><br><span class="line">   |     ------------^^^^^^^^-</span><br><span class="line">   |     |           |</span><br><span class="line">   |     |           borrowed value does not live long enough</span><br><span class="line">   |     argument requires that `box_i32` is borrowed for `&#x27;static`</span><br><span class="line">10 | &#125;</span><br><span class="line">   | - `box_i32` dropped here while still borrowed</span><br></pre></td></tr></table></figure>

<p>报错了，不是说T是各种类型的集合吗，为什么不行呢？我们再改改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(&amp;box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过了，通过思考，恍然大悟，Rust到处存在模式匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	t: &amp;T,</span><br><span class="line">	&amp;T: &amp;Box&lt;i32&gt;,</span><br><span class="line">	T: Box&lt;i32&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就出现有意思的局面了，在<code>T: &#39;static</code>限定下，除了<code>&amp;&#39;static T</code>，其类型为，直接迎合了我们<code>T</code> 只包含所有权类型的误区，其例子为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型变量</strong></td>
<td><code>T</code></td>
<td><code>&amp;T</code></td>
<td><code>&amp;mut T</code></td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>i32</code></td>
<td><code>&amp;i32</code>,  <code>&amp;mut i32</code></td>
<td><code>&amp;mut i32</code></td>
</tr>
</tbody></table>
<p>真有意思</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 14.04下安装SS及Proxychains</title>
    <url>/2017/04/03/ubuntu-14-04%E4%B8%8B%E5%AE%89%E8%A3%85ss%E5%8F%8Aproxychains/</url>
    <content><![CDATA[<p><em>很多机友因为要同步源码而去访问那些不存在的网站，所以我写这个FQ教程</em></p>
<p><strong>安装SS教程</strong></p>
<ul>
<li>建议直接安装shadowsocks-qt5，原来的方法不支持某些协议和加密方式</li>
<li>设置 PPA 源并安装 shadowsocks-qt5 sudo add-apt-repository ppa:hzwhuang&#x2F;ss-qt5</li>
<li>更新源 sudo apt-get update</li>
<li>安装shadowsocks-qt5 sudo apt-get install shadowsocks-qt5</li>
</ul>
<p>*如果遇到依赖问题，输入 sudo apt-get -f install libappindicator1 libindicator7 接下来就是代理设置了，如果使用qt5的话，跳过文章中间的SS安装旧的教程，到文章下面看Proxychains安装配置教程</p>
<p><strong>旧的安装SS教程</strong></p>
<ul>
<li>关于Ububtu 16.04 安装SS似乎可以直接 sudo apt-get install shadowsocks</li>
<li>国际惯例，先更新一下源，输入命令 sudo apt-get update</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469460824414830.png"></p>
<ul>
<li>输入命令 sudo apt-get install python-gevent python-pip</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461037102621.png"></p>
<ul>
<li>安装SS程序 输入命令 sudo pip install shadowsocks</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461120150276.png"></p>
<ul>
<li>配置SS 输入命令生成配置文件 gedit ss.json</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461210126751.png"></p>
<ul>
<li>添加配置 { “server”:”服务器的ip”, “server_port”:服务器端口, “local_address”:”127.0.0.1″, “local_port”:1080, “password”:”密码”, “timeout”:300, “method”:”aes-256-cfb”, “fast_open”:false }</li>
<li>注意：method是加密方法，这里默认是aes-256-cfb，不一样的请自行修改</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461434173767.png"> 然后保存 * 运行SS 输入命令 sslocal -c ss.json <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461621557248.png"> 到这SS客户端就安装和配置完了，然而现在还需要代理，可以设置系统全局代理，但是又只想让一个应用翻墙，比如同步源码。所以现在需要Proxychains</p>
<p><strong>Proxychains安装教程</strong></p>
<ul>
<li>输入命令安装Proxychains sudo apt-get install proxychains</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461834467776.png"></p>
<ul>
<li>进行配置 输入命令 sudo gedit &#x2F;etc&#x2F;proxychains.conf</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469461913162769.png"></p>
<ul>
<li>在最后，把socks4改成socks5，后面的端口改成你的SS的本地端口，我这写1080</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469462067144115.png"> 然后就完成了Proxychains的安装与配置 * 最后在SS运行的情况下运行Proxychains，在命令前加上proxychains就行，比如输入 proxychains firefox <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607261469462402126322.png"></p>
<ul>
<li>然后进Google测试一下</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/04/201607251469462218621332.png"></p>
<ul>
<li>同步源码输入 proxychains repo sync</li>
</ul>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li><a class="link"   href="mailto:&#x73;&#x70;&#x78;&#103;&#x30;&#x39;&#x32;&#51;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;" >&#x73;&#x70;&#x78;&#103;&#x30;&#x39;&#x32;&#51;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio Code C/C++环境配置</title>
    <url>/2019/09/20/visual-studio-code-c%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Visual Studio Code 与 Visual Studio IDE 的区别</p>
<p>根据<a class="link"   href="https://code.visualstudio.com/docs/supporting/faq#_what-is-the-difference-between-visual-studio-code-and-visual-studio-ide" >官方的说法<i class="fas fa-external-link-alt"></i></a>有</p>
<h2 id="What-is-the-difference-between-Visual-Studio-Code-and-Visual-Studio-IDE"><a href="#What-is-the-difference-between-Visual-Studio-Code-and-Visual-Studio-IDE" class="headerlink" title="What is the difference between Visual Studio Code and Visual Studio IDE?#"></a>What is the difference between Visual Studio Code and Visual Studio IDE?<a class="link"   href="https://code.visualstudio.com/docs/supporting/faq#_what-is-the-difference-between-visual-studio-code-and-visual-studio-ide" >#<i class="fas fa-external-link-alt"></i></a></h2><p>Visual Studio Code is a streamlined code editor with support for development operations like debugging, task running, and version control. It aims to provide just the tools a developer needs for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs, such as <a class="link"   href="https://visualstudio.microsoft.com/" >Visual Studio IDE<i class="fas fa-external-link-alt"></i></a>. 按照我的理解就是前者是个轻量级代码编辑器， 手动装好拓展和相关的编译器，就可以编写调试相应的程序，主要针对文件而不是项目，是Sublime或Atom on Electron的竞争对手；而Visual Studio IDE一看“IDE”就感觉不简单， IDE即Integrated Development Environment， 是个集成开发环境，微软旨在让其成为世界上最好的IDE，其功能强大的同时程序也不小。相比之下，Visual Studio 才是我们初选者的选择。</p>
<p>安装Visual Studio Code</p>
<p>Visual Studio Code 支持的平台有自家的Windows， MacOS，以及Linux，<a class="link"   href="https://code.visualstudio.com/" >点我跳官网下载<i class="fas fa-external-link-alt"></i></a>，但是Visual Studio Code 在Windows上配置相对麻烦（在MacOS直接编译C程序时，其系统会自动弹出安装GCC的选项；在Linux应该装个GCC就好了（这个我还真没试过））,直接全选了，毕竟还挺实用的，然后安装即可。 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920202803.png"></p>
<p>配置Visual Studio Code</p>
<p>先创建一个写代码的地方吧，比如Code，然后随意在其中创建一个C文件，会弹出下载C拓展的选项，点击安装（Install）即可，如图 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920203656.png"> 拓展是有了，但是编译器还没，根据<a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw" >官方文档<i class="fas fa-external-link-alt"></i></a>，使用的是<a class="link"   href="http://mingw-w64.org/doku.php/start" >Mingw<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download" >下载地址<i class="fas fa-external-link-alt"></i></a>，打开安装程序，如下图选择（应该没人用32位了吧<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">） <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20191127191914.png"> 这里以我的安装目录为演示，以下步骤都以这个目录为示范，目录不同请自行修改下面的配置文件 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20191127192158.png"> 然后在终端打入path</p>
<p>setx path “%path%;c:\Software\mingw64\bin”</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920205756.png"> 接下来生成配置文件，进入Code文件夹，按下Ctrl+Shift+P， 如图选择 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210340.png"> 然后我们输入path地址及选择编译器 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210455.png"> 我修改了标准参数（c11-&gt;c99) <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210536.png"> 接下来创建task.json, 官方有</p>
<h2 id="Create-a-build-task"><a href="#Create-a-build-task" class="headerlink" title="Create a build task#"></a>Create a build task<a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw#_create-a-build-task" >#<i class="fas fa-external-link-alt"></i></a></h2><p>Next, create a <code>tasks.json</code> file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler to create an executable file based on the source code.</p>
<ol>
<li><p>From the main menu, choose <strong>View &gt; Command Palette</strong> and then type “task” and choose <strong>Tasks: Configure Default Build Task</strong>. In the dropdown, select <strong>Create tasks.json file from template</strong>, then choose <strong>Others</strong>. VS Code creates a minimal <code>tasks.json</code> file and opens it in the editor. （可以直接在.vscode中创建个task.json,然后copy进去保存即可）</p>
</li>
<li><p>Go ahead and replace the entire file contents with the following code snippet （下面是我的配置）:</p>
<p>{<br>“tasks”: [<br>    {<br>        “type”: “shell”,<br>        “label”: “Build”,<br>        “command”: “D:\\Software\\mingw64\\bin\\gcc.exe”,<br>        “args”: [<br>            “-g”,<br>            “${file}”,<br>            “-o”,<br>            “${fileDirname}\\${fileBasenameNoExtension}.exe”,<br>            “-std&#x3D;gnu99”,<br>            “-fexec-charset&#x3D;GBK”,<br>            “-finput-charset&#x3D;UTF-8”<br>        ],<br>        “options”: {<br>            “cwd”: “D:\\Software\\mingw64\\bin”<br>        },<br>        “group”: {<br>            “kind”: “build”,<br>            “isDefault”: true<br>        },<br>        “presentation”: {<br>            “reveal”: “silent”<br>        }<br>    }<br>],<br>“version”: “2.0.0”<br>}</p>
</li>
</ol>
<pre><code> 
</code></pre>
<p>官方对于launch.json有</p>
<h2 id="Configure-debug-settings"><a href="#Configure-debug-settings" class="headerlink" title="Configure debug settings"></a>Configure debug settings</h2><p>Next, we’ll configure VS Code to launch the GCC debugger (gdb.exe) when you press F5.</p>
<ol>
<li>From the Command Palette, type “launch” and then choose <strong>Debug: Open launch.json</strong>. Next, choose the <strong>GDB&#x2F;LLDB</strong> environment.</li>
<li>For <code>program</code>, use the program name <code>helloworld.exe</code> (which matches what you specified in <code>tasks.json</code>). You will need to adjust your <code>miDebuggerPath</code> value to match the path to your Mingw-w64 installation.</li>
<li>By default, the C++ extension adds a breakpoint to the first line of <code>main</code>. The <code>stopAtEntry</code> value is set to <code>true</code> to cause the debugger to stop on that breakpoint. You can set this to <code>false</code> if you prefer to ignore it.</li>
<li>Optionally, set <code>externalConsole</code> to <code>true</code> to run the program in an external console.</li>
</ol>
<p>Your complete <code>launch.json</code> file should look something like this （已修改，可以直接在.vscode中创建个launch.json,然后copy进去保存即可）:</p>
<p>{<br>    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.<br>    &#x2F;&#x2F; Hover to view descriptions of existing attributes.<br>    &#x2F;&#x2F; For more information, visit: <a class="link"   href="https://go.microsoft.com/fwlink/?linkid=830387" >https://go.microsoft.com/fwlink/?linkid=830387<i class="fas fa-external-link-alt"></i></a><br>    “version”: “0.2.0”,<br>    “configurations”: [</p>
<pre><code>    &#123;
        &quot;name&quot;: &quot;gcc.exe build and debug active file&quot;,
        &quot;type&quot;: &quot;cppdbg&quot;,
        &quot;request&quot;: &quot;launch&quot;,
        &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,
        &quot;args&quot;: \[\],
        &quot;stopAtEntry&quot;: false,
        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,
        &quot;environment&quot;: \[\],
        &quot;externalConsole&quot;: false,
        &quot;MIMode&quot;: &quot;gdb&quot;,
        &quot;miDebuggerPath&quot;: &quot;D:\\\\Software\\\\mingw64\\\\bin\\\\gdb.exe&quot;,
        &quot;setupCommands&quot;: \[
            &#123;
                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                &quot;ignoreFailures&quot;: true
            &#125;
        \],
        &quot;preLaunchTask&quot;: &quot;Build&quot;
    &#125;
\]
</code></pre>
<p>}</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920212812.png"> 全部创建完成后，即可在该目录下写C了，换目录时记得把.vscode文件复制过去</p>
<p>Visual Studio Code 的功能</p>
<p>编译运行当然没有问题</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213458.png"></p>
<p>调试当然正常</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213608.png"></p>
<p>代码补全当然好用</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213655.png"></p>
<p>还有很好的规范学习工具——格式化功能</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213747.png"></p>
<p>安装中文拓展</p>
<p>进入拓展，搜索安装并重启软件即可 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920214456.png"></p>
<p>对于一些功能的思考</p>
<ol>
<li>代码补全对于我这种新手来说有利也有弊，利的方面自然是写的快了，但可能会因此忘掉语法的写法，这是致命的（上机考试的软件可没有代码补全），所以我这种新手觉得还是多自己写写，而代码补全可以作为学习的工具来研究语法该怎样写</li>
<li>格式化代码是个好东西，它可以让我们的代码更规范，但是我们不能因为这功能而写出杂乱的代码，我们应该学习如何写，格式化的代码值得研究</li>
</ol>
<p>相关文件（供网络不通<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">的朋友下载）及懒人直接配置文件（copy大法好）</p>
<p><a class="link"   href="https://spxg-my.sharepoint.com/:f:/g/personal/spxg_spxg_me/Ev-LK1V5bStGk4b6_8hSw9ABnV2_X9prihAWeJY19tVBlw?e=CoXdwY" >一键轻松<i class="fas fa-external-link-alt"></i></a></p>
<p> </p>
<p>引用文章</p>
<ol>
<li><a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw" >Using Mingw-w64 in VS Code<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/weibo1230123/article/details/89259510" >Visual Studio 2017和Visual Studio Code的区别！<i class="fas fa-external-link-alt"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>使用七牛云对象存储功能加速WordPress站</title>
    <url>/2017/05/07/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8A%9F%E8%83%BD%E5%8A%A0%E9%80%9Fwordpress%E7%AB%99/</url>
    <content><![CDATA[<p><strong><em>起因</em></strong></p>
<p>今天我拿网站出去装B的时候，有人反应根本打不开，我觉得他们<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/240d82b5cc0483b9.jpg">，我怎么能好好访问呢。后来想想我服务器是国外的，而我<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/QQ%E6%88%AA%E5%9B%BE20170507170542.png">全程FQ<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/TX4WO77_DT8SX1J3_YD.jpg">，看来并不是他们的问题<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/8MM7WXFSKR1YKC8.gif">，然后我就有了使用七牛云对象储存功能给国内访问博客加速的想法</p>
<p><strong><em>开始</em></strong></p>
<ul>
<li>当然是先去<a class="link"   href="https://www.qiniu.com/" >七牛云官网<i class="fas fa-external-link-alt"></i></a>注册使用，注册就不多说了</li>
<li>创建一个对象储存空间，名称自己写，区域自己选，然后就创建吧<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/G0AAGUQO6A34I7.png"></li>
<li>得到测试域名，下面要用到<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/LJ0Q_6LH1H6V_@UZO.png"></li>
<li>写上镜像源，选择镜像储存，格式http(s):&#x2F;&#x2F;xxxx.xxx&#x2F;  robots.txt不使用默认，<a class="link"   href="https://cloud.wordpress-1253676827.file.myqcloud.com/robots.txt" >robots.txt下载<i class="fas fa-external-link-alt"></i></a><img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/1RNCUZD61_TVO1IPFLE.png"></li>
<li>回到博客后台，安装七牛云插件，两个都要安装，先装WPJAM Basic<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/N10PV@ZXOBL@NFOD8PK.png"></li>
<li>设置插件，七牛域名就是第三步得到的测试域名，前面要加上http:&#x2F;&#x2F;    七牛空间名就是第二步你写的空间名 ACCESS KRY和SECRET KEY下一步说                                          <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/TMSOST3@QRMH7Q8Y.png"></li>
<li>获取ACCESS KEY和SECRET KEY    打开个人面板-密匙管理，然后创建密匙 复制粘贴到上一步就好啦                                                                                                                                                 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/H8@5SJ56M_LMZ7YSIV2.png">                                  <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/OWS22_PQS9R1U6CQ9SPO1.png"></li>
<li>保存设置就可以用了，我是国外服务器，加速明显还省流量<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/OCX0S72UA31@CWGZLSE49.jpg"></li>
</ul>
<p><em><strong>我遇到的问题</strong></em></p>
<p>高高高兴弄完准备测试的时候，打开网站<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/8_Q91CRCI6_AVHUGTG1.png">丫的卡着啊<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/TEJ622NMRFOYJSP5Q7R.jpg">，后来发现问题，把<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/26911VWEX8KASWPYJX1.png">js删掉就好啦<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/0NFPC3GTVEI32KOI.gif">。我用的akina主题 很不错 到这，你是否感觉访问本站快些了呢，快说是 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/05/CCBG1WK8P7R80ML9PP.gif"></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>内网穿透神器frp和路由SSL及Aria2远程下载配置（Padavan）</title>
    <url>/2017/08/06/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%A5%9E%E5%99%A8frp%E5%92%8C%E8%B7%AF%E7%94%B1ssl%E9%85%8D%E7%BD%AE%EF%BC%88padavan%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言-路由公网IP请只看SSL获取）"><a href="#前言-路由公网IP请只看SSL获取）" class="headerlink" title="前言(路由公网IP请只看SSL获取）"></a>前言(路由公网IP请只看SSL获取）</h1><p><a class="link"   href="https://github.com/fatedier/frp" >frp<i class="fas fa-external-link-alt"></i></a>是优秀的内网穿透工具，配置起来简单，这里主要说的是ssh和web的配置，其他的在官方说明文档有 SSL的获取可以看逗比根据地的 <a class="link"   href="https://doub.io/wlzy-28/" >免费申请SSL证书教程<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="1-获取frp"><a href="#1-获取frp" class="headerlink" title="1.获取frp"></a>1.获取<a class="link"   href="https://github.com/fatedier/frp/releases" >frp<i class="fas fa-external-link-alt"></i></a></h2><p>我这里使用Linux 64位系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>之后再解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xzvf frp_0.13.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-开始配置"><a href="#2-开始配置" class="headerlink" title="2.开始配置"></a>2.开始配置</h2><p>进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd frp_0.13.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>目录中有frps.ini frpc.ini等文件，frps是服务端用的，也就是有公网ip的机器；frpc.ini是客户端用的，也就是内网的机器。 如果仅仅使用ssh功能，服务端就不需要配置了，先用screen,免得关闭服务端的ssh后，frp断线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen -S frp</span><br></pre></td></tr></table></figure>

<p>之后再启用服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>

<p>没报错啥的就好了</p>
<ul>
<li>开始客户端的配置 同样的下载解压步骤就不重复了 打开配置文件frpc.ini</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano frpc.ini</span><br></pre></td></tr></table></figure>

<p>然后将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_addr =</span><br></pre></td></tr></table></figure>

<p>后面改成自己服务器的IP地址，然后运行（至于Padavan，只要在相应界面改一下配置启动就行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure>

<p>最后用xshell vssh jucessh等ssh软件就可访问，<em>这里ssh默认为6000</em> ,ubuntu啥的需要装openssh，arch linux请看<a class="link"   href="https://wiki.archlinux.org/index.php/Secure_Shell_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" >Arch_wiki<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="3-Web界面的穿透，这里主要讲https"><a href="#3-Web界面的穿透，这里主要讲https" class="headerlink" title="3.Web界面的穿透，这里主要讲https"></a>3.Web界面的穿透，这里主要讲https</h2><ul>
<li>首先在Padavan&gt;系统管理&gt;服务 中开启https</li>
<li>然后在下方<img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/08/A0C4EB4B-6498-4DD4-ADFF-6E38AD0FAFAB.jpg">，分别填上crt文件和key文件的内容</li>
<li>之后开始配置服务端frps.ini</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano frps.ini</span><br></pre></td></tr></table></figure>

<p>下方输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vhost_http_port = 80</span><br><span class="line">vhost_https_port = 443</span><br></pre></td></tr></table></figure>

<p>如果端口有冲突，换一个。保存，运行。这里用了http和https，http用来aria下载，https用来Web岂不美滋滋 然后就是客户端的配置了 在Padavan&gt;花生壳内网穿透&gt;frp中添加内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[web01]</span><br><span class="line"># https web</span><br><span class="line">type = https</span><br><span class="line">local_ip = 192.168.123.1</span><br><span class="line">local_port = 443</span><br><span class="line">custom_domains = xxxxxx.xxx</span><br><span class="line"></span><br><span class="line">[web02]</span><br><span class="line"># aria</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.123.1</span><br><span class="line">local_port = 6800</span><br><span class="line">custom_domains = xxxxxx.xxx</span><br></pre></td></tr></table></figure>

<p>这里custom_domains是域名，需要将域名解析到服务端 保存，运行即可</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><ul>
<li>Web <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/08/QQ20170806-220521.png"></li>
<li>Aria2远程下载 <img src="http://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2017/08/QQ20170806-220554.png"></li>
</ul>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>写OS遇到的让人印象深刻的Bug（RISC-V）</title>
    <url>/2021/02/23/%E5%86%99OS%E9%81%87%E5%88%B0%E7%9A%84%E8%AE%A9%E4%BA%BA%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84Bug%EF%BC%88RISC-V%EF%BC%89/</url>
    <content><![CDATA[<p><strong>常在河边走，哪有不湿鞋</strong></p>
<span id="more"></span>

<h4 id="我来分享两个我在写OS过程中遇到的Bug"><a href="#我来分享两个我在写OS过程中遇到的Bug" class="headerlink" title="我来分享两个我在写OS过程中遇到的Bug"></a>我来分享两个我在写OS过程中遇到的Bug</h4><h5 id="折腾Trap遇到的玄学Bug"><a href="#折腾Trap遇到的玄学Bug" class="headerlink" title="折腾Trap遇到的玄学Bug"></a>折腾Trap遇到的玄学Bug</h5><p><em>众所周知，玄学Bug总归还是找得到原因的。</em> </p>
<p>当Trap发生时，会进入<code>stvec</code>寄存器所存的地址的位置（Direct Mode），这个位置一般是Trap处理函数。我将我的测试函数写入<code>stvec</code>寄存器，然后通过<code>ebreak</code>指令产生中断，发现测试正常，之后就把无用的<code>println!</code>删除了。不删不要紧一删就跑不起来了，当时给我郁闷的。</p>
<p>既然Bug出现了，那就得排除修复，第一个检查的就是地址有没有写入<code>stvec</code>，经过GDB调试，发现地址写入后随即变成0x0，但是加个<code>println!</code>又修复了，这是为啥呢？没有思路的我开始破罐子破摔，开始写入一些随机值（1, 2, 3, 4 …..），一写我就发现了，只有4的倍数的值可以被成功写入，接着我就想难道有对其要求？翻出riscv-privileged，查了查，发现这一句话：</p>
<p><em>The BASE field in stvec is a WARL field that can hold any valid virtual or physical address,</em><br><em>subject to the following alignment constraints: the address <strong>must always be at least 4-byte aligned</strong>,</em><br><em>and the MODE setting may impose additional alignment constraints on the value in the BASE</em><br><em>field</em></p>
<p><del>妈的，还是得好好学习。</del>写入的地址必须要是4字节对齐的，所以那行<code>println!</code>引发的Bug只是影响了地址值，加上恰好是4个字节。我的解决办法是在<code>trap entry</code>前加入对齐指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># stvec need align 4 byte</span><br><span class="line">.align 4</span><br><span class="line"></span><br><span class="line">_trap_entry: </span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h5 id="自以为写的很好的代码引发的不易发现的Bug"><a href="#自以为写的很好的代码引发的不易发现的Bug" class="headerlink" title="自以为写的很好的代码引发的不易发现的Bug"></a>自以为写的很好的代码引发的不易发现的Bug</h5><p><em>众所周知，不易发现的问题代码常常是自己觉得写的不错的代码</em></p>
<p><strong>RAII</strong>，全称<strong>资源获取即初始化</strong>（英语：<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）。RAII要求，资源的有效期与持有资源的<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F&action=edit&redlink=1" >对象的生命期<i class="fas fa-external-link-alt"></i></a>严格绑定，即由对象的<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" >构造函数<i class="fas fa-external-link-alt"></i></a>完成<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D&action=edit&redlink=1" >资源的分配<i class="fas fa-external-link-alt"></i></a>（获取），同时由<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" >析构函数<i class="fas fa-external-link-alt"></i></a>完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2&action=edit&redlink=1" >资源泄露<i class="fas fa-external-link-alt"></i></a>问题。——<a class="link"   href="https://zh.wikipedia.org/wiki/RAII" >来自维基百科RAII<i class="fas fa-external-link-alt"></i></a></p>
<p>在写虚拟地址模块时，写了个<code>FrameTracker</code>结构，目的是记录每一个被分配的物理页号（PPN）,同时为其实现了<code>Drop Trait</code>，在其生命周期结束的时候会自动释放资源。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">stack_frame_dealloc</span>(<span class="keyword">self</span>.ppn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码写的差不多时，我进行测试，发现直接<code>LoadPageFault</code>，发现在进行虚拟页转换的时候，二级页表指向的指针居然是某个虚拟地址的物理地址，以至于访问次虚拟地址的时候直接<code>LoadPageFault</code>，调试2天毫无头绪。就在刚刚才想到可能原本的地址被释放了，然后再次分配了<code>Frame</code>，这本不应该发生。顺着这思路马上就找到了Bug，而我记得在写这段代码时十分满意。。。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span> = <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>),</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">stack_frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, f.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            f.ppn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_permission.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到Bug发生的原因是：<code>FrameTracker</code>实现了<code>Drop Trait</code>，这是一种RAII，在其生命周期结束的时候会自动释放资源，我直接使用了<code>clone()</code>，而导致生命周期在函数执行完时结束，接着释放了资源，对应的<code>PPN</code>即被标记为未分配的状态。</p>
<p>修复自然简单，不Clone不就完了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span> = <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>),</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">stack_frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ppn</span> = f.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, f);</span><br><span class="line">            ppn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_permission.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>暗影精灵4 i5-8300H + GTX1050Ti 黑苹果 EFI</title>
    <url>/2019/06/21/%E6%9A%97%E5%BD%B1%E7%B2%BE%E7%81%B54-i5-8300h-gtx1050ti-%E9%BB%91%E8%8B%B9%E6%9E%9C-efi/</url>
    <content><![CDATA[<p><a href="https://996.icu/"><img src="https://img.shields.io/badge/link-996.icu-red.svg" alt="996.icu"></a></p>
<p><a href="https://github.com/996icu/996.ICU/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-Anti%20996-blue.svg" alt="LICENSE"></a></p>
<p>首先感谢<a class="link"   href="https://github.com/canwdev/omen15dc-hackintosh" >canwdev<i class="fas fa-external-link-alt"></i></a>的付出与Art_Chen的指导帮助</p>
<p><a class="link"   href="https://github.com/Spxg/omen15dc-hackintosh" >EFI文件地址<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>使用的系统镜像是 <a class="link"   href="http://bbs.pcbeta.com/viewthread-1815882-1-1.html" >【Len’s DMG】macOS Mojave 10.14.5 18F132 With Clover 4928 and OC 双引导镜像<i class="fas fa-external-link-alt"></i></a></p>
<p>安装过程可参考 <a class="link"   href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" >macOS安装教程兼小米Pro安装过程记录<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="可用功能："><a href="#可用功能：" class="headerlink" title="可用功能："></a>可用功能：</h3><ul>
<li>UHD630 集成显卡驱动</li>
<li>亮度调节、内置键盘、触摸板</li>
<li>音频、录音驱动，可接耳机</li>
<li>有线上网、USB接口功能</li>
<li>电池</li>
<li>温度传感器</li>
<li>睡眠</li>
<li>开机不再黑屏</li>
<li>亮度保存</li>
</ul>
<h3 id="无效功能："><a href="#无效功能：" class="headerlink" title="无效功能："></a>无效功能：</h3><ul>
<li>无线网卡</li>
<li>HDMI、DP输出(无法解决，因为走的是独显)</li>
<li>键盘灯功能(键盘灯无法在系统内配置,FN+F4为睡眠,但可在刚开机时配置）</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>drivers64UEFI中EmuVariableUefi-64.efi请勿删除，否则无法安装系统及关机重启</li>
</ul>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/06/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-06-21-%E4%B8%8B%E5%8D%881.35.43.png" alt="完成效果"></p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/06/QQ20190621-134227.png" alt="电池与传感器"></p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ul>
<li><a class="link"   href="http://bbs.pcbeta.com/viewthread-1815882-1-1.html" >【Len’s DMG】macOS Mojave 10.14.5 18F132 With Clover 4928 and OC 双引导镜像<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" >macOS安装教程兼小米Pro安装过程记录<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.daliansky.net/Intel-FB-Patcher-tutorial-and-insertion-pose.html" >Hackintool(原Intel FB-Patcher)使用教程及插入姿势<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.daliansky.net/CoffeeLake-UHD-630-black-screen-direct-bright-screen-and-correct-adjustment-of-brightness-adjustment.html" >【黑果小兵】CoffeeLake UHD 630黑屏、直接亮屏及亮度调整的正确插入姿势<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.daliansky.net/Tutorial-Using-Hackintool-to-open-the-correct-pose-of-the-8th-generation-core-display-HDMI-or-DVI-output.html" >教程：利用Hackintool打开第8代核显HDMI&#x2F;DVI输出的正确姿势<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>解决Shadowsocks-Manager中Office 365中SMTP不能用的问题</title>
    <url>/2018/08/15/%E8%A7%A3%E5%86%B3shadowsocks-manager%E4%B8%ADoffice-365%E4%B8%ADsmtp%E4%B8%8D%E8%83%BD%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><em>最近换了个服务器，想体验更好的科学上网服务，于是就打算搭建webgui，项目地址<a class="link"   href="https://github.com/shadowsocks/shadowsocks-manager" >Shadowsocks-Manager<i class="fas fa-external-link-alt"></i></a></em></p>
<p>       安装过程一波三折，好在都解决了，最让我头疼的是邮件一直都无法使用，我是Office365的smtp，起初以为是vps的问题，后来发现用Gmail可以使用，博客的Office365也正常</p>
<ul>
<li>首先我尝试添加端口号587，后来也算是有所进展，毕竟成功通信了，却无法登陆  ，报错如下图</li>
</ul>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/08/TIM%E6%88%AA%E5%9B%BE20180815155551.png"><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/08/%E6%8D%95%E8%8E%B7.png"></p>
<p><em>经过查询资料，发现了<a class="link"   href="https://www.npmjs.com/package/node-smtp-client" >node-smtp-client<i class="fas fa-external-link-alt"></i></a>的用法</em></p>
<ul>
<li>原来这个程序还有个secure的用法，默认这个参数为true，据我了解，office365 smtp是没有SSL加密的，故将true改成false即可，成功解决问题</li>
</ul>
<p> </p>
<p>解决办法</p>
<p>在yml的email选项中添加如下代码即可</p>
<p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2018/08/TIM%E6%88%AA%E5%9B%BE20180815162116.png"></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
  <entry>
    <title>记一次寻找 OpenWrt 问题的过程</title>
    <url>/2022/04/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>固件是我自己编译的，源码来自 <a class="link"   href="https://github.com/coolsnowwolf/lede" >lean<i class="fas fa-external-link-alt"></i></a>，是个十分不错的项目。</p>
<p><strong>问题：</strong><br>今天我发现我 <code>OpenWrt</code> 存在 <code>luci</code> 界面下修改设置无法生效的问题，就像这样：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/issue.png" alt="无法生效"><br>万能的重启后，仅第一次可以成功设置。</p>
<span id="more"></span>

<p><strong>过程：</strong><br>有着运气加成</p>
<p>开始由 <code>ZeroTier</code> 入手，原本以为是插件的问题，但是寻找了相关提交也没发现有端倪。然后试了试其他插件也是如此，便判定是固件问题。</p>
<p>翻看了系统日志和内核日志也没有收获，直到我查看了系统进程：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/top.png" alt="进程"><br><del>这，这不对吧？这今天谁，谁要陷害我？</del></p>
<p>我们可以看到一排排的 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/sh /sbin/luci-reload xxx</span><br><span class="line">lock /var/run/luci-reload</span><br></pre></td></tr></table></figure>

<p>根据我的直觉，判断出可能出现死锁了。尝试 <code>kill</code> 所有 <code>luci-reload</code>  和 <code>lock</code> 进程，之后修改设置成功生效！但是也只成功一次，且发现 <code>lock</code> 进程依旧存在。</p>
<p>搜索一波<a class="link"   href="https://github.com/coolsnowwolf/luci/blob/3fe64081aa5c14895d25dbadf7484dde61ed7a1d/modules/luci-base/root/sbin/luci-reload" >源文件<i class="fas fa-external-link-alt"></i></a>，可以看到有这么几行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lock <span class="string">&quot;/var/run/luci-reload&quot;</span></span><br><span class="line"></span><br><span class="line">config_load ucitrack</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line">	config_foreach apply_config <span class="variable">$i</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f <span class="string">&quot;/var/run/luci-reload-status&quot;</span></span><br><span class="line">lock -u <span class="string">&quot;/var/run/luci-reload&quot;</span></span><br></pre></td></tr></table></figure>

<p>意思就是，应用配置文件的时候加个锁，应用完成后解锁。</p>
<p>是没有执行到解锁程序吗？我做了个测试，创建了 <code>/var/run/luci-reload-status</code> 文件，随后应用设置，发现文件被删除，所以可以得出解锁程序有被执行。</p>
<p>至此问题很清晰了，<strong>第一次应用设置后，锁未释放，导致接下来的应用设置无法获取锁，所以无法进行设置</strong>。</p>
<p>试了试，确实是这样：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/try.jpg" alt="尝试"><br>现在的问题转变为什么解锁失败了</p>
<p>一顿搜索，找到了 <code>lock</code> 程序的<a class="link"   href="https://github.com/coolsnowwolf/lede/blob/master/package/utils/busybox/patches/220-add_lock_util.patch" >源代码<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2006 Felix Fietkau &lt;nbd@nbd.name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is free software, licensed under the GNU General Public License v2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//config:config LOCK</span></span><br><span class="line"><span class="comment">//config:	bool &quot;lock&quot;</span></span><br><span class="line"><span class="comment">//config:	default n</span></span><br><span class="line"><span class="comment">//config:	help</span></span><br><span class="line"><span class="comment">//config:	  Small utility for using locks in scripts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//applet:IF_LOCK(APPLET(lock, BB_DIR_BIN, BB_SUID_DROP))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//kbuild:lib-$(CONFIG_LOCK) = lock.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//usage:#define lock_trivial_usage NOUSAGE_STR</span></span><br><span class="line"><span class="comment">//usage:#define lock_full_usage &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;busybox.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> unlock = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> waitonly = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> try_lock = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *file;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [-suw] &lt;filename&gt;\n&quot;</span></span><br><span class="line">	                <span class="string">&quot;	-s	Use shared locking\n&quot;</span></span><br><span class="line">	                <span class="string">&quot;	-u	Unlock\n&quot;</span></span><br><span class="line">	                <span class="string">&quot;	-w	Wait for the lock to become free, don&#x27;t acquire lock\n&quot;</span></span><br><span class="line">			<span class="string">&quot;	-n	Don&#x27;t wait for the lock to become free. Fail with exit code\n&quot;</span></span><br><span class="line">					<span class="string">&quot;\n&quot;</span>, name);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_unlock</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	flock(fd, LOCK_UN);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *f;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((f = fopen(file, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fscanf</span>(f, <span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">		kill(i, SIGTERM);</span><br><span class="line"></span><br><span class="line">	fclose(f);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	<span class="type">char</span> pidstr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(file, O_RDWR | O_CREAT | O_EXCL, <span class="number">0700</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((fd = open(file, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags = shared ? LOCK_SH : LOCK_EX;</span><br><span class="line">	flags |= try_lock ? LOCK_NB : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flock(fd, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t lock %s\n&quot;</span>, file);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		signal(SIGKILL, exit_unlock);</span><br><span class="line">		signal(SIGTERM, exit_unlock);</span><br><span class="line">		signal(SIGINT, exit_unlock);</span><br><span class="line">		<span class="keyword">if</span> (waitonly)</span><br><span class="line">			exit_unlock(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!waitonly) &#123;</span><br><span class="line">			lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">			ftruncate(fd, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">sprintf</span>(pidstr, <span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">			write(fd, pidstr, <span class="built_in">strlen</span>(pidstr));</span><br><span class="line">			close(fd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lock_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> MAIN_EXTERNALLY_VISIBLE;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lock_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> **args = &amp;argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> c = argc - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((*args != <span class="literal">NULL</span>) &amp;&amp; (*args)[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">		<span class="type">char</span> *ch = *args;</span><br><span class="line">		<span class="keyword">while</span> (*(ch) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">switch</span>(*ch) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">					waitonly = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">					shared = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">					unlock = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">					try_lock = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c--;</span><br><span class="line">		args;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">1</span>)</span><br><span class="line">		usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	file = *args;</span><br><span class="line">	<span class="keyword">if</span> (unlock)</span><br><span class="line">		<span class="keyword">return</span> do_unlock();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> do_lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们可知加解锁步骤：</p>
<ul>
<li>加锁后，<code>fork</code> 出子进程注册 <code>signal</code>，当 <code>SIGKILL</code> 等三种情况时候触发解锁代码解锁</li>
<li>父进程将子进程的 <code>pid</code> 写入文件，之后退出</li>
<li>解锁通过读取文件，获取 <code>pid</code> 值 <code>kill</code> 掉子程序解锁</li>
</ul>
<p>如果工作正常的话，我们应该可以在加锁后的文件中得到 pid，可是发现文件为空:<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/file_empty.png" alt="文件为空"></p>
<p>可以知道 <code>pid</code> 并没有写入文件里。看着代码思来想去，并没有发现有什么问题。</p>
<p>而这时的我看了看这个文件<a class="link"   href="https://github.com/coolsnowwolf/lede/commit/d17bbf492dc6d44691726d16f25a03cb8550921a" >最近的提交<i class="fas fa-external-link-alt"></i></a>：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/commit.png" alt="最近的提交"><br><code>lean</code> 把它 <code>revert</code> 回去了，这是为啥呢？看了看上一个提交是扩大了 <code>pidstr</code> 的空间，因为不扩大的话，当 <code>pid</code> 过大的时候会造成 <code>buffer overflow</code>，提交本身意图并没有问题。此时的我并没有注意到问题的严重性，直到我看到了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数写反了，函数的定义是</span></span><br><span class="line"><span class="comment">// int snprintf(char *str, size_t size, const char *format, ...);</span></span><br><span class="line"><span class="built_in">snprintf</span>(<span class="keyword">sizeof</span>(pidstr), pidstr, <span class="string">&quot;%d\n&quot;</span>, pid);</span><br></pre></td></tr></table></figure>
<p><em>让我不由得在心里默念 <code>Rust</code> 大法好！</em></p>
<p>看了看我的版本，刚好是这两个提交之间（运气太差）。吓得我连夜跑路：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/build.png" alt="更新"></p>
<p><strong>总结：</strong><br>这个问题主要是由于提交者参数使用错误，仓库 <code>reviewer</code> 也没发现问题以及 <code>C</code> 对类型检查的不严格导致的, <del>Rust 大法好</del>。发现问题到解决的过程还是很愉快的。</p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
  </entry>
</search>

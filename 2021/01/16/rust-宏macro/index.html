<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Spxg"><meta name="description" content="随便写写"><meta name="author" content="Spxg"><title>Rust 宏(Macro) | 不安全的网站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"unsafe.me",root:"/",language:"en",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!1,expand_all:!0,init_open:!1},style:{primary_color:"#FF6666",avatar:"/images/avatar.png",favicon:"/images/favicon.ico",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!1,scale:!1},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"在学习中实践，在实践中学习。"},scroll:{progress_bar:{enable:!1},percent:{enable:!0}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!1},version:"3.4.5"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"}</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="不安全的网站" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/favicon.ico"> </a><a class="logo-title" href="/">不安全的网站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Rust 宏(Macro)</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">Spxg</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-01-16 21:25:12</span> <span class="mobile">2021-01-16 21:25</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Rust/">Rust</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.6k Words</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>13 Mins</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="Rust-宏-Macro"><a href="#Rust-宏-Macro" class="headerlink" title="Rust 宏(Macro)"></a>Rust 宏(Macro)</h2><p>​ 众所周知, <em>Rust_提供了一个强大的宏系统，可进行元编程(metaprogramming)。_Rust</em> 中的宏几乎无处不在，其实你们写的第一个_Rust_ 程序里面就已经用到了宏，比如<code>println!</code>，宏看起来和函数很像，只不过名称末尾有一个感叹号 <code>!</code> 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。 ​ 由于才疏学浅，不敢班门弄斧，所以主要从例子出发，不深究原理，文章适合有_Rust_基础的同学看，官方文档 <a class="link" target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-06-macros.html">The Rust Programming Language<i class="fas fa-external-link-alt"></i></a> ​ 我的Github: <a class="link" target="_blank" rel="noopener" href="https://github.com/Spxg">上铺小哥Spxg<i class="fas fa-external-link-alt"></i></a></p><h3 id="与C的宏有什么不同"><a href="#与C的宏有什么不同" class="headerlink" title="与C的宏有什么不同"></a>与C的宏有什么不同</h3><p>_C_的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define ONE_PLUE_ONE <span class="number">2</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ONE_PLUS_ONE);</span><br></pre></td></tr></table></figure><p>_Rust_的宏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> ONE_PLUS_ONE &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ONE_PLUS_ONE!());</span><br></pre></td></tr></table></figure><p>可能有同学要问了，_Rust_的宏与_C_的相比有什么不同。不同的是，_Rust_的宏会展开为抽象语法树(AST，abstract syntax tree)，而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。</p><h3 id="动手整个map"><a href="#动手整个map" class="headerlink" title="动手整个map!"></a>动手整个map!</h3><p>了解_Rust_的同学，相比对<code>vec!</code>不陌生，<code>vec![1, 2, 3]</code>相当于</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可见宏使用可以带来便捷，那我们可不可以为_HashMap_实现相似的功能呢，当然可以，考虑下面几行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     &quot;me&quot; =&gt; &quot;laji&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;you&quot; =&gt; &quot;good&quot;  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;me&quot;</span>, <span class="string">&quot;laji&quot;</span>);</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;you&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们不妨设计成_key_ &#x3D;&gt; _value_的模式，像Ruby一样，将其插入到一个Map中，如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">marco_rule! map &#123;</span><br><span class="line">    <span class="comment">// $(...), + will be expanded for each matches </span></span><br><span class="line">    <span class="comment">// Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x</span></span><br><span class="line">    ($($key: expr =&gt; $value: expr), +) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        $(map.<span class="title function_ invoke__">insert</span>($key, $value);), +</span><br><span class="line">        map</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用map!来生成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">map</span> = map!(</span><br><span class="line">    <span class="string">&quot;me&quot;</span> =&gt; <span class="string">&quot;laji&quot;</span>,</span><br><span class="line">    <span class="string">&quot;you&quot;</span> =&gt; <span class="string">&quot;good&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不难发现，其精髓还是对号入座，可以在脑子里替换进去</p><h3 id="玩个大点的"><a href="#玩个大点的" class="headerlink" title="玩个大点的"></a>玩个大点的</h3><p>同学们都知道<code>fibonacci</code>数，我们都知道这列值可以永远持续下去，定义一个<code>fibonacci</code>的求值函数略显困难。显然，返回一整列值并不实际。我们真正需要的，应是某种具有惰性求值性质的东西——只在必要的时候才进行运算求值。 在Rust中，这样的需求表明，是<code>Iterator</code>派上用场的时候了。实现迭代器并不十分困难，但比较繁琐：你得自定义一个类型，弄明白该在其中存储什么，然后为它实现<code>Iterator</code> trait。 其实，递推关系足够简单；几乎所有的递推关系都可被抽象出来，变成一小段由宏驱动的代码生成机制。 但是我们不写<code>fibonacci</code>，写了就有点大材小用<del>脱裤子放屁</del>了，就为了一个<code>fibonacci</code>写宏多不值啊，编译器展开和自己写还不是一样。所以，我们整个比较通用的。</p><h4 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h4><p>同学们都是学过来的，想必都遇到过这些东西： <code>a = 1, 2, ..., n</code> <code>a = 1.0, ..., n * a[n - 1]</code> <code>fib = 0, 1, ..., fib[n - 1] + fib[n - 2]</code> 我们通过自己设计的宏假装实现一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recurrence!(a[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... n);</span><br><span class="line">recurrence!(a[n]: <span class="type">f64</span> = <span class="number">1.0</span> ... n * a[n - <span class="number">1</span>]);</span><br><span class="line">recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h4 id="列出方程"><a href="#列出方程" class="headerlink" title="列出方程"></a>列出方程</h4><p>以<code>fibonacci</code>为例， <code>fib[0] = 0</code> <code>fib[1] = 1</code> <code>fib[2] = fib[2 - 1] + fib[2 - 2] = 1</code> <code>fib[3] = fib[3 - 1] + fib[3 - 2] = 2</code> <code>......</code> 可以知道，我们只要有两个初始值就可以通过迭代算出任意一个<code>fibonacci</code>数，所以只需定义一个数组，列出方程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pseudocode</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">fib</span> = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = fib.<span class="title function_ invoke__">length</span>();</span><br><span class="line"><span class="keyword">if</span> n &lt; length &#123;</span><br><span class="line">    fib[n]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// offset is the times of iter</span></span><br><span class="line">    fib[n - <span class="number">1</span> - offset + length] + fib[n - <span class="number">2</span> - offset + length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计程序"><a href="#设计程序" class="headerlink" title="设计程序"></a>设计程序</h4><p>有了方程后，我们开始做更细化的操作，解决问题，如<code>fib[n - offset + length]</code>。有的同学就要问了：这有啥问题，不是很符合逻辑吗？的确很符合，但是有大坑啊，<code>n - 2 - offset</code> 在<code>n</code>为2开始的时候程序就panic了。原因是：在_Rust_中， 数组的Index是<code>usize</code>类型，必是大于等于0，<code>n</code>为2开始，其中间运算小于0，直接爆炸，所以我们需要改改逻辑：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">1</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">2</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">fib[a <span class="keyword">as</span> <span class="type">usize</span>] + fib[b <span class="keyword">as</span> <span class="type">usize</span>];</span><br></pre></td></tr></table></figure><p>看了以后，可能有些同学觉得这<del>尼玛是啥</del>太复杂了，很不美观，所以我们再想想。在_Rust_中，有个<code>std::num::Wrapping</code>类型，它就是干这事的，话不多说，看代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provides intentionally-wrapped arithmetic on T.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations like + on u32 values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrapping arithmetic can be achieved either through methods like wrapping_add, or through the Wrapping&lt;T&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The underlying value can be retrieved through the .0 index of the Wrapping tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Wrapping</span>(n);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(offset);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = <span class="title function_ invoke__">Wrapping</span>(length);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">real_index</span> = n - offset + length;</span><br><span class="line">fib[real_index.<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>总算比上面一坨好看多了。</p><h4 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h4><p><em>Rust</em> 提供了Iterator trait，使我们更好使用，而且还有好多实现了Iterator类型的方法，用它就完了，trait 长这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span></span><br><span class="line"><span class="comment">//  The type of the elements being iterated over.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Required methods</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"><span class="comment">//  Advances the iterator and returns the next value.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns None when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling next() again may or may not eventually start returning Some(Item) again at some point.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_Rust_中，<code>[]</code>操作来源于<code>Index&lt;T&gt;</code> trait, 其中的<code>T</code>就是Index的类型，在这里就是<code>usize</code>，<code>Index&lt;T&gt;</code> trait 长这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Index</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: ?<span class="built_in">Sized</span></span><br><span class="line">    <span class="comment">// The returned type after indexing.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required methods</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Output</span><br><span class="line">    <span class="comment">// Performs the indexing (container[index]) operation.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接开始写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Index;</span><br><span class="line"><span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    mem: [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    pos: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            mem: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            pos: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    slice: &amp;<span class="symbol">&#x27;a</span> [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">        &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="keyword">self</span>.pos;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fib</span> = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset &#125;;</span><br><span class="line">                fib[offset - <span class="number">1</span>] + fib[offset - <span class="number">2</span>]</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// move forward</span></span><br><span class="line">                <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fib</span> = Solution::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter 10 times</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">f</span> <span class="keyword">in</span> fib.<span class="title function_ invoke__">take</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行一把梭，轻松秒杀：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><p>有了这个经验，写宏就很简单了，首先要解决的是，怎么让宏知道你初始有几个元素？套娃就对了！直接上代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        $recur</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一波：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] * fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: `$inits:expr` may be followed by `...`, which is not allowed <span class="keyword">for</span> `expr` fragments</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">8</span>:<span class="number">62</span></span><br><span class="line">  </span><br><span class="line"><span class="number">8</span>      ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">                                                                ^^^ not allowed after `expr` fragments</span><br><span class="line">  </span><br><span class="line">  = note: allowed there are: `=&gt;`, `,` or `;`</span><br></pre></td></tr></table></figure><p>看来是不能用<code>...</code>了，那我们换成<code>=&gt;</code></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + =&gt; $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        ($recur)</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = recurrence!(s1[n]: <span class="type">usize</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; n);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1.take(6) is&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = recurrence!(s2[n]: <span class="type">f64</span> = <span class="number">1.0</span> =&gt; s2[n - <span class="number">1</span>] * n <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>).<span class="title function_ invoke__">fold</span>(<span class="number">0.0</span>, acc, x acc + x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2.take(3)&#x27;s sum is &#123;&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = recurrence!(s3[n]: <span class="type">usize</span> = <span class="number">1</span> =&gt; n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3.take(5) is &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fib</span> = recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sixth</span> = fib.<span class="title function_ invoke__">nth</span>(<span class="number">6</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the sixth of fibonacci is &#123;&#125;&quot;</span>, sixth);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;RUST NB!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) is</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-------------</span><br><span class="line">s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>)<span class="symbol">&#x27;s</span> sum is <span class="number">4</span></span><br><span class="line">-------------</span><br><span class="line">s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>) is [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">-------------</span><br><span class="line">the sixth of fibonacci is <span class="number">8</span></span><br><span class="line">-------------</span><br><span class="line">RUST NB!</span><br></pre></td></tr></table></figure><h3 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h3><ul><li><p><a class="link" target="_blank" rel="noopener" href="https://danielkeep.github.io/tlborm/">The Little Book of Rust Macros<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link" target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language<i class="fas fa-external-link-alt"></i></a></p></li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>Post title：Rust 宏(Macro)</li><li>Post author：Spxg</li><li>Create time：2021-01-16 21:25:12</li><li>Post link：https://unsafe.me/2021/01/16/rust-宏macro/</li><li>Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/01/24/t-static/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">T and &#39;static</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2020/10/16/fat32-filesystem-library/"><span class="title flex-center"><span class="post-nav-title-item">FAT32 FileSystem Library</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Spxg</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">Totalview&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E5%AE%8F-Macro"><span class="nav-text">Rust 宏(Macro)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EC%E7%9A%84%E5%AE%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-text">与C的宏有什么不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%89%8B%E6%95%B4%E4%B8%AAmap"><span class="nav-text">动手整个map!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%A9%E4%B8%AA%E5%A4%A7%E7%82%B9%E7%9A%84"><span class="nav-text">玩个大点的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text">设计模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%96%B9%E7%A8%8B"><span class="nav-text">列出方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F"><span class="nav-text">设计程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%93%8D%E4%BD%9C"><span class="nav-text">开始操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0"><span class="nav-text">引用文章</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>
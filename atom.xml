<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不安全的网站</title>
  
  
  <link href="https://unsafe.me/atom.xml" rel="self"/>
  
  <link href="https://unsafe.me/"/>
  <updated>2022-04-05T12:46:56.143Z</updated>
  <id>https://unsafe.me/</id>
  
  <author>
    <name>Spxg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次寻找 OpenWrt 问题的过程</title>
    <link href="https://unsafe.me/2022/04/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://unsafe.me/2022/04/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-05T02:05:10.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<p>固件是我自己编译的，源码来自 <a class="link"   href="https://github.com/coolsnowwolf/lede" >lean<i class="fas fa-external-link-alt"></i></a>，是个十分不错的项目。</p><p><strong>问题：</strong><br>今天我发现我 <code>OpenWrt</code> 存在 <code>luci</code> 界面下修改设置无法生效的问题，就像这样：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/issue.png" alt="无法生效"><br>万能的重启后，仅第一次可以成功设置。</p><span id="more"></span><p><strong>过程：</strong><br>有着运气加成</p><p>开始由 <code>ZeroTier</code> 入手，原本以为是插件的问题，但是寻找了相关提交也没发现有端倪。然后试了试其他插件也是如此，便判定是固件问题。</p><p>翻看了系统日志和内核日志也没有收获，直到我查看了系统进程：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/top.png" alt="进程"><br><del>这，这不对吧？这今天谁，谁要陷害我？</del></p><p>我们可以看到一排排的 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh /sbin/luci-reload xxx</span><br><span class="line">lock /var/run/luci-reload</span><br></pre></td></tr></table></figure><p>根据我的直觉，判断出可能出现死锁了。尝试 <code>kill</code> 所有 <code>luci-reload</code>  和 <code>lock</code> 进程，之后修改设置成功生效！但是也只成功一次，且发现 <code>lock</code> 进程依旧存在。</p><p>搜索一波<a class="link"   href="https://github.com/coolsnowwolf/luci/blob/3fe64081aa5c14895d25dbadf7484dde61ed7a1d/modules/luci-base/root/sbin/luci-reload" >源文件<i class="fas fa-external-link-alt"></i></a>，可以看到有这么几行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="string">&quot;/var/run/luci-reload&quot;</span></span><br><span class="line"></span><br><span class="line">config_load ucitrack</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line">config_foreach apply_config <span class="variable">$i</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f <span class="string">&quot;/var/run/luci-reload-status&quot;</span></span><br><span class="line">lock -u <span class="string">&quot;/var/run/luci-reload&quot;</span></span><br></pre></td></tr></table></figure><p>意思就是，应用配置文件的时候加个锁，应用完成后解锁。</p><p>是没有执行到解锁程序吗？我做了个测试，创建了 <code>/var/run/luci-reload-status</code> 文件，随后应用设置，发现文件被删除，所以可以得出解锁程序有被执行。</p><p>至此问题很清晰了，<strong>第一次应用设置后，锁未释放，导致接下来的应用设置无法获取锁，所以无法进行设置</strong>。</p><p>试了试，确实是这样：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/try.jpg" alt="尝试"><br>现在的问题转变为什么解锁失败了</p><p>一顿搜索，找到了 <code>lock</code> 程序的<a class="link"   href="https://github.com/coolsnowwolf/lede/blob/master/package/utils/busybox/patches/220-add_lock_util.patch" >源代码<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2006 Felix Fietkau &lt;nbd@nbd.name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is free software, licensed under the GNU General Public License v2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//config:config LOCK</span></span><br><span class="line"><span class="comment">//config:bool &quot;lock&quot;</span></span><br><span class="line"><span class="comment">//config:default n</span></span><br><span class="line"><span class="comment">//config:help</span></span><br><span class="line"><span class="comment">//config:  Small utility for using locks in scripts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//applet:IF_LOCK(APPLET(lock, BB_DIR_BIN, BB_SUID_DROP))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//kbuild:lib-$(CONFIG_LOCK) = lock.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//usage:#define lock_trivial_usage NOUSAGE_STR</span></span><br><span class="line"><span class="comment">//usage:#define lock_full_usage &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;busybox.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> unlock = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> waitonly = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> try_lock = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *file;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [-suw] &lt;filename&gt;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;-sUse shared locking\n&quot;</span></span><br><span class="line">                <span class="string">&quot;-uUnlock\n&quot;</span></span><br><span class="line">                <span class="string">&quot;-wWait for the lock to become free, don&#x27;t acquire lock\n&quot;</span></span><br><span class="line"><span class="string">&quot;-nDon&#x27;t wait for the lock to become free. Fail with exit code\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span>, name);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_unlock</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">flock(fd, LOCK_UN);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((f = fopen(file, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fscanf</span>(f, <span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">kill(i, SIGTERM);</span><br><span class="line"></span><br><span class="line">fclose(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pid;</span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"><span class="type">char</span> pidstr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(file, O_RDWR | O_CREAT | O_EXCL, <span class="number">0700</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((fd = open(file, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags = shared ? LOCK_SH : LOCK_EX;</span><br><span class="line">flags |= try_lock ? LOCK_NB : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flock(fd, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t lock %s\n&quot;</span>, file);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">signal(SIGKILL, exit_unlock);</span><br><span class="line">signal(SIGTERM, exit_unlock);</span><br><span class="line">signal(SIGINT, exit_unlock);</span><br><span class="line"><span class="keyword">if</span> (waitonly)</span><br><span class="line">exit_unlock(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!waitonly) &#123;</span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">ftruncate(fd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(pidstr, <span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">write(fd, pidstr, <span class="built_in">strlen</span>(pidstr));</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lock_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> MAIN_EXTERNALLY_VISIBLE;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lock_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> **args = &amp;argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> c = argc - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((*args != <span class="literal">NULL</span>) &amp;&amp; (*args)[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line"><span class="type">char</span> *ch = *args;</span><br><span class="line"><span class="keyword">while</span> (*(ch) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span>(*ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">waitonly = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">shared = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">unlock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">try_lock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c--;</span><br><span class="line">args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">1</span>)</span><br><span class="line">usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">file = *args;</span><br><span class="line"><span class="keyword">if</span> (unlock)</span><br><span class="line"><span class="keyword">return</span> do_unlock();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> do_lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可知加解锁步骤：</p><ul><li>加锁后，<code>fork</code> 出子进程注册 <code>signal</code>，当 <code>SIGKILL</code> 等三种情况时候触发解锁代码解锁</li><li>父进程将子进程的 <code>pid</code> 写入文件，之后退出</li><li>解锁通过读取文件，获取 <code>pid</code> 值 <code>kill</code> 掉子程序解锁</li></ul><p>如果工作正常的话，我们应该可以在加锁后的文件中得到 pid，可是发现文件为空:<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/file_empty.png" alt="文件为空"></p><p>可以知道 <code>pid</code> 并没有写入文件里。看着代码思来想去，并没有发现有什么问题。</p><p>而这时的我看了看这个文件<a class="link"   href="https://github.com/coolsnowwolf/lede/commit/d17bbf492dc6d44691726d16f25a03cb8550921a" >最近的提交<i class="fas fa-external-link-alt"></i></a>：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/commit.png" alt="最近的提交"><br><code>lean</code> 把它 <code>revert</code> 回去了，这是为啥呢？看了看上一个提交是扩大了 <code>pidstr</code> 的空间，因为不扩大的话，当 <code>pid</code> 过大的时候会造成 <code>buffer overflow</code>，提交本身意图并没有问题。此时的我并没有注意到问题的严重性，直到我看到了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数写反了，函数的定义是</span></span><br><span class="line"><span class="comment">// int snprintf(char *str, size_t size, const char *format, ...);</span></span><br><span class="line"><span class="built_in">snprintf</span>(<span class="keyword">sizeof</span>(pidstr), pidstr, <span class="string">&quot;%d\n&quot;</span>, pid);</span><br></pre></td></tr></table></figure><p><em>让我不由得在心里默念 <code>Rust</code> 大法好！</em></p><p>看了看我的版本，刚好是这两个提交之间（运气太差）。吓得我连夜跑路：<br><img src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/build.png" alt="更新"></p><p><strong>总结：</strong><br>这个问题主要是由于提交者参数使用错误，仓库 <code>reviewer</code> 也没发现问题以及 <code>C</code> 对类型检查的不严格导致的, <del>Rust 大法好</del>。发现问题到解决的过程还是很愉快的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;固件是我自己编译的，源码来自 &lt;a class=&quot;link&quot;   href=&quot;https://github.com/coolsnowwolf/lede&quot; &gt;lean&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;，是个十分不错的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br&gt;今天我发现我 &lt;code&gt;OpenWrt&lt;/code&gt; 存在 &lt;code&gt;luci&lt;/code&gt; 界面下修改设置无法生效的问题，就像这样：&lt;br&gt;&lt;img src=&quot;/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%BB%E6%89%BEopenwrt%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B/issue.png&quot; alt=&quot;无法生效&quot;&gt;&lt;br&gt;万能的重启后，仅第一次可以成功设置。&lt;/p&gt;</summary>
    
    
    
    <category term="技术相关" scheme="https://unsafe.me/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>13-机器人的运动范围</title>
    <link href="https://unsafe.me/2021/06/07/13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://unsafe.me/2021/06/07/13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2021-06-07T15:21:12.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br><code>1 &lt;= n,m &lt;= 100</code><br><code>0 &lt;= k &lt;= 20</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" >https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li></ul><p>本题和上一道矩阵中的路径，思路基本是相同的，需要注意的是我们得建立一个表，来判断节点是否被访问过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += row % <span class="number">10</span>;</span><br><span class="line">            row /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += col % <span class="number">10</span>;</span><br><span class="line">            col /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == m ||</span><br><span class="line">            col &lt; <span class="number">0</span> || col == n ||</span><br><span class="line">            <span class="built_in">sum</span>(row, col) &gt; k ||</span><br><span class="line">            map[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">bfs</span>(row - <span class="number">1</span>, col, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row + <span class="number">1</span>, col, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row, col - <span class="number">1</span>, m, n, k, map) +</span><br><span class="line">               <span class="built_in">bfs</span>(row, col + <span class="number">1</span>, m, n, k, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n, k, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;上有一个m行n列的方格，从坐标 &lt;code&gt;[0,0]&lt;/code&gt; 到坐标 &lt;code&gt;[m-1,n-1]&lt;/code&gt; 。一个机器人从坐标 &lt;code&gt;[0, 0]&lt;/code&gt; 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&amp;#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&amp;#x3D;19。请问该机器人能够到达多少个格子？&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>12-矩阵中的路径</title>
    <link href="https://unsafe.me/2021/06/05/12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://unsafe.me/2021/06/05/12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2021-06-05T16:52:48.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="leetcode"></p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br><code>1 &lt;= board.length &lt;= 200</code><br><code>1 &lt;= board[i].length &lt;= 200</code><br><code>board 和 word 仅由大小写英文字母组成</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" >https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zh.cppreference.com/w/cpp/string/basic_string" >string<i class="fas fa-external-link-alt"></i></a></li></ul><p>本题考查的是广度优先遍历，遍历需要个起点，然后遍历还需要记录是否为访问过某个值（不然打圈圈就没意思了），还有就是要考虑到遍历何时结束。这里的起点便是要查找的字符串的第一个值，结束即是找到了整个字符串，关于记录是否为访问过某个值，这里可以在数组中修改字符为’\0’，为访问过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col, string&amp; word, <span class="type">int</span> found)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断是否找到了，found为找到的字符数</span></span><br><span class="line">        <span class="keyword">if</span> (found == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断row和col是否越界</span></span><br><span class="line"><span class="comment">// 再判断board[row][col] == &#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.<span class="built_in">size</span>() || </span><br><span class="line">            col &lt; <span class="number">0</span> || col == board[<span class="number">0</span>].<span class="built_in">size</span>() ||</span><br><span class="line">            board[row][col] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到对应的字符，找到字符数加1</span></span><br><span class="line"><span class="comment">// 标记为访问过</span></span><br><span class="line"><span class="comment">// 周围遍历完后恢复字符</span></span><br><span class="line"><span class="comment">// 否则直接false</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == word[found]) &#123;</span><br><span class="line">            found += <span class="number">1</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="type">bool</span> res = <span class="built_in">bfs</span>(board, row - <span class="number">1</span>, col, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row + <span class="number">1</span>, col, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row, col + <span class="number">1</span>, word, found) ||</span><br><span class="line">                       <span class="built_in">bfs</span>(board, row, col - <span class="number">1</span>, word, found);</span><br><span class="line">            found -= <span class="number">1</span>;</span><br><span class="line">            board[row][col] = word[found];</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 这可不是脱裤子放屁</span></span><br><span class="line">                    <span class="comment">// 直接return bfs(board, row, col, word, 0) 是不正确的</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">bfs</span>(board, row, col, word, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 二维字符网格 &lt;code&gt;board&lt;/code&gt; 和一个字符串单词 &lt;code&gt;word&lt;/code&gt; 。如果 &lt;code&gt;word&lt;/code&gt; 存在于网格中，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;br&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;br&gt;例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/11/04/word2.jpg&quot; alt=&quot;leetcode&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>11-旋转数组的最小数字</title>
    <link href="https://unsafe.me/2021/06/05/11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://unsafe.me/2021/06/05/11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2021-06-05T15:56:56.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" >https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构</p><ul><li>无</li></ul><p>做这题极易一把梭写出<code>sort</code>取值，或者调用相关函数，或者又像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽说能够通过测试，但是在面试时估计就会被HR记住。看题目可以知道原来的数组是个递增序列，然后把某一段提到前面来了，所以这里有两个递增序列。最小值在第二个递增区的第一个值，这里可以使用二分法(还有特殊情况)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rignt = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="comment">// [01111] -&gt; [11101]</span></span><br><span class="line">        <span class="comment">// 这种情况无法使用二分法，所以顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[left] == numbers[rignt]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[left] &lt; numbers[rignt]) &#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (numbers[left] &gt; numbers[rignt]) &#123;</span><br><span class="line">            <span class="comment">// [3, 4, [5, 1] ,2]</span></span><br><span class="line">            <span class="comment">// 5 &gt; 1</span></span><br><span class="line">            <span class="comment">// 3 - 2 = 1</span></span><br><span class="line">            <span class="keyword">if</span> (rignt - left == <span class="number">1</span>) &#123;</span><br><span class="line">                mid = rignt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + rignt) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为真说明mid指向的值在第一个递增区，缩小范围</span></span><br><span class="line">            <span class="comment">// 否则说明其在第二个递增区，缩小范围</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[left] &lt;= numbers[mid]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rignt = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  &lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>10-II-青蛙跳台阶问题</title>
    <link href="https://unsafe.me/2021/06/05/10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://unsafe.me/2021/06/05/10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-05T15:27:59.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br><code>0 &lt;= n &lt;= 100</code><br>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" >https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li>无</li></ul><p>本题考查的其实也是斐波那契数列，设跳上<code>n</code>级台阶有<code>f(n)</code>种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上<code>1</code>级或<code>2</code>级台阶。<br>当为<code>1</code>级台阶： 剩<code>n−1</code>个台阶，此情况共有<code>f(n-1)</code>种跳法；<br>当为<code>2</code>级台阶： 剩<code>n−2</code>个台阶，此情况共有<code>f(n-2)</code>种跳法。<br>即<code>f(n) = f(n - 1) + f(n - 2)</code>，根据提示有<code>f(0) = 1</code>，可以写出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (one + two) % <span class="number">1000000007</span>;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 &lt;code&gt;n&lt;/code&gt; 级的台阶总共有多少种跳法。&lt;br&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>10-I-斐波那契数列</title>
    <link href="https://unsafe.me/2021/06/05/10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://unsafe.me/2021/06/05/10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2021-06-05T13:57:24.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br><code>0 &lt;= n &lt;= 100</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" >https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li>无</li></ul><p>本题主要考查的是对Fibonacci的理解，并且看看你是不是只会暴力递归（指没有记录算过的值）；这里我们可以发现，某一项的值与前两项有关，所以我们只需要记录每次的前两项即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = 3</span></span><br><span class="line"><span class="comment">// one = 1, two = 0</span></span><br><span class="line"><span class="comment">// res = 1 + 0</span></span><br><span class="line"><span class="comment">// two = one</span></span><br><span class="line"><span class="comment">// one = res</span></span><br><span class="line"><span class="comment">// res = 1 + 1 = 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (one + two) % <span class="number">1000000007</span>;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;写一个函数，输入 &lt;code&gt;n&lt;/code&gt; ，求斐波那契（Fibonacci）数列的第 &lt;code&gt;n&lt;/code&gt; 项（即 &lt;code&gt;F(N)&lt;/code&gt;）。斐波那契数列的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0,   F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;br&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>09-用两个栈实现队列</title>
    <link href="https://unsafe.me/2021/06/05/09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://unsafe.me/2021/06/05/09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-06-05T12:54:31.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br><code>1 &lt;= values &lt;= 10000</code><br><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" >https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/stack" >stack<i class="fas fa-external-link-alt"></i></a></li></ul><p>我遇到的问题是题目看不懂，看了leetcode @Modest Almeida的解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1.[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] 这里是要执行的方法，从左到右执行。</span><br><span class="line">2.[[],[3],[],[]]对应上面的方法，是上面方法的参数。</span><br><span class="line">3.CQueue和deleteHead方法不需要指定数字，只有添加才需要指定数字</span><br><span class="line"></span><br><span class="line">1.创建队列，返回值为null</span><br><span class="line">2.将3压入栈，返回值为null</span><br><span class="line">3.将栈底的元素删除，也就是消息队列中先进来的元素，所以是deleteHead，返回该元素的数值，所以为3</span><br><span class="line">4.继续删除栈底的元素，但是没有元素了，所以返回-1</span><br><span class="line"></span><br><span class="line">所以就有了下面的输出 输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p>本题考查的是对队列和栈的了解，队列的特点是先进先出(FIFO)，栈的特点是先进后出(FILO)，我们可以把一个栈用作<code>appendTail</code>，一个栈用作<code>deleteHead</code>，当要<code>deleteHead</code>时，将<code>stack1</code>的数据倒写到<code>stack2</code>，此时<code>stack2</code>即为队列的布局，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">high address -&gt; low address</span><br><span class="line"></span><br><span class="line">appendTail 1:</span><br><span class="line">stack1: [1],</span><br><span class="line">stack2: []</span><br><span class="line"></span><br><span class="line">appendTail 2:</span><br><span class="line">stack1: [1， 2],</span><br><span class="line">stack2: []</span><br><span class="line"></span><br><span class="line">deleteHead:</span><br><span class="line">stack1: [],</span><br><span class="line">stack2: [2, 1],</span><br><span class="line">stack2: [2],</span><br><span class="line"></span><br><span class="line">deleteHead:</span><br><span class="line">stack1: [],</span><br><span class="line">stack2: [1],</span><br><span class="line">stack2: [],</span><br></pre></td></tr></table></figure><p>根据分析，可以写出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 &lt;code&gt;appendTail&lt;/code&gt; 和 &lt;code&gt;deleteHead&lt;/code&gt; ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，&lt;code&gt;deleteHead&lt;/code&gt; 操作返回 -1 )&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>07-重建二叉树</title>
    <link href="https://unsafe.me/2021/06/05/07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://unsafe.me/2021/06/05/07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-06-05T02:14:56.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><span id="more"></span><p>例如，给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" >https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li><li>HashMap，即是<a class="link"   href="https://zh.cppreference.com/w/cpp/container/unordered_map" >unordered_map<i class="fas fa-external-link-alt"></i></a></li></ul><p>这题主要考查的是对二叉树前序遍历，中序遍历和递归的理解程度，它们是以这样分布的：<br>前序遍历：<code>[根节点, [左子树], [右子树]]</code><br>中序遍历：<code>[[左子树], 根结点, [右子树]]</code></p><p>假设有这么一课二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br></pre></td></tr></table></figure><p>前序遍历为：[3, 9, 20]<br>中序遍历为：[9, 3, 20]</p><p>前序遍历的第一个元素为3，即3是根节点，左右子树节点分别为[9]，[20]，把它们看成一个单独的树，他们的前序分别为[9]，[20]，第一个元素即为根节点，所以还原成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildInner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历第一个值就是根节点的值</span></span><br><span class="line">        <span class="type">int</span> root_preorder_index = preorder_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得值</span></span><br><span class="line">        <span class="type">int</span> root_val = preorder[root_preorder_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到它在中序遍历中的位置，为了计算左右子树的个数</span></span><br><span class="line">        <span class="type">int</span> root_inorder_index = map[root_val];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算出左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> sub_size = root_inorder_index - inorder_left;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildInner</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + sub_size, inorder_left, root_inorder_index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildInner</span>(preorder, inorder, preorder_left + sub_size + <span class="number">1</span>, preorder_right, root_inorder_index + <span class="number">1</span>, inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = preorder.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了快速找到每个根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            map[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildInner</span>(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>06-从尾到头打印链表</title>
    <link href="https://unsafe.me/2021/06/04/06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://unsafe.me/2021/06/04/06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2021-06-04T16:49:23.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>0 &lt;= 链表长度 &lt;= 10000</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof" >https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li></ul><p>这题相对简单，考查的是对<code>vector</code>的了解程度，以及链表遍历方法。反着输出值可以使用<code>insert</code>指定插入位置为<code>begin</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), node-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>05-替换空格</title>
    <link href="https://unsafe.me/2021/06/04/05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://unsafe.me/2021/06/04/05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2021-06-04T16:33:30.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。 </p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>0 &lt;= s 的长度 &lt;= 10000</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof" >https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/string/basic_string" >string<i class="fas fa-external-link-alt"></i></a></li></ul><p>这题比较简单，主要考查的是对<code>string</code>类的了解程度，有很多办法，我使用的是<code>replace</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> idx = s.<span class="built_in">find_first_of</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (idx == string::npos) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">            s.<span class="built_in">replace</span>(idx, <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。 &lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>04-二维数组中的查找</title>
    <link href="https://unsafe.me/2021/06/04/04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://unsafe.me/2021/06/04/04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2021-06-04T16:12:08.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><span id="more"></span><p><strong>示例:</strong><br>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。<br>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p><p><strong>限制：</strong><br><code>0 &lt;= n &lt;= 1000</code><br><code>0 &lt;= m &lt;= 1000</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" >https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li></ul><p>本题完全可以使用暴力搜索完成，但是。。。<br>“每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序”，说明有更明智的方法。<br>我们可以从右上角开始判断，当目标值小于当前元素左移，否则下移，如此反复，直到得出结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不从左上角开始判断的原因使是：向下，向右都是递增的</span></span><br><span class="line"><span class="comment">// 不从右下角开始判断的原因使是：向上，向左都是递减的</span></span><br><span class="line"><span class="comment">// 这里选择右上角开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n_size = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m_size = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = m_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &lt; n_size &amp;&amp; m &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> val = matrix[n][m];</span><br><span class="line">            <span class="keyword">if</span> (target == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; val) &#123;</span><br><span class="line">                m -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>03-数组中重复的数字</title>
    <link href="https://unsafe.me/2021/06/04/03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://unsafe.me/2021/06/04/03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2021-06-04T15:42:18.000Z</published>
    <updated>2022-04-05T12:46:56.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure><p><strong>限制：</strong><br><code>2 &lt;= n &lt;= 100000</code></p><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" >https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>题解：</strong><br>使用的数据结构：</p><ul><li><a class="link"   href="https://zh.cppreference.com/w/cpp/container/vector" >vector<i class="fas fa-external-link-alt"></i></a></li><li>HashSet，即是<a class="link"   href="https://zh.cppreference.com/w/cpp/container/unordered_set" >unordered_set<i class="fas fa-external-link-alt"></i></a></li></ul><p>遍历<code>nums</code>值，将值一一插入<code>set</code>，当再次插入已经插入的值的时候，表现为<code>set.insert(value).second</code>值为<code>false</code>，即找到重复数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用HashSet插入数，当值已经插入过时set.insert(value).second值为false</span></span><br><span class="line"><span class="comment">// 即找到重复的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> value = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (!set.<span class="built_in">insert</span>(value).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;找出数组中重复的数字。&lt;br&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指 Offer" scheme="https://unsafe.me/categories/%E5%89%91%E6%8C%87-Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>写OS遇到的让人印象深刻的Bug（RISC-V）</title>
    <link href="https://unsafe.me/2021/02/23/%E5%86%99OS%E9%81%87%E5%88%B0%E7%9A%84%E8%AE%A9%E4%BA%BA%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84Bug%EF%BC%88RISC-V%EF%BC%89/"/>
    <id>https://unsafe.me/2021/02/23/%E5%86%99OS%E9%81%87%E5%88%B0%E7%9A%84%E8%AE%A9%E4%BA%BA%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84Bug%EF%BC%88RISC-V%EF%BC%89/</id>
    <published>2021-02-23T15:26:22.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常在河边走，哪有不湿鞋</strong></p><span id="more"></span><h4 id="我来分享两个我在写OS过程中遇到的Bug"><a href="#我来分享两个我在写OS过程中遇到的Bug" class="headerlink" title="我来分享两个我在写OS过程中遇到的Bug"></a>我来分享两个我在写OS过程中遇到的Bug</h4><h5 id="折腾Trap遇到的玄学Bug"><a href="#折腾Trap遇到的玄学Bug" class="headerlink" title="折腾Trap遇到的玄学Bug"></a>折腾Trap遇到的玄学Bug</h5><p><em>众所周知，玄学Bug总归还是找得到原因的。</em> </p><p>当Trap发生时，会进入<code>stvec</code>寄存器所存的地址的位置（Direct Mode），这个位置一般是Trap处理函数。我将我的测试函数写入<code>stvec</code>寄存器，然后通过<code>ebreak</code>指令产生中断，发现测试正常，之后就把无用的<code>println!</code>删除了。不删不要紧一删就跑不起来了，当时给我郁闷的。</p><p>既然Bug出现了，那就得排除修复，第一个检查的就是地址有没有写入<code>stvec</code>，经过GDB调试，发现地址写入后随即变成0x0，但是加个<code>println!</code>又修复了，这是为啥呢？没有思路的我开始破罐子破摔，开始写入一些随机值（1, 2, 3, 4 …..），一写我就发现了，只有4的倍数的值可以被成功写入，接着我就想难道有对其要求？翻出riscv-privileged，查了查，发现这一句话：</p><p><em>The BASE field in stvec is a WARL field that can hold any valid virtual or physical address,</em><br><em>subject to the following alignment constraints: the address <strong>must always be at least 4-byte aligned</strong>,</em><br><em>and the MODE setting may impose additional alignment constraints on the value in the BASE</em><br><em>field</em></p><p><del>妈的，还是得好好学习。</del>写入的地址必须要是4字节对齐的，所以那行<code>println!</code>引发的Bug只是影响了地址值，加上恰好是4个字节。我的解决办法是在<code>trap entry</code>前加入对齐指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># stvec need align 4 byte</span><br><span class="line">.align 4</span><br><span class="line"></span><br><span class="line">_trap_entry: </span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h5 id="自以为写的很好的代码引发的不易发现的Bug"><a href="#自以为写的很好的代码引发的不易发现的Bug" class="headerlink" title="自以为写的很好的代码引发的不易发现的Bug"></a>自以为写的很好的代码引发的不易发现的Bug</h5><p><em>众所周知，不易发现的问题代码常常是自己觉得写的不错的代码</em></p><p><strong>RAII</strong>，全称<strong>资源获取即初始化</strong>（英语：<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）。RAII要求，资源的有效期与持有资源的<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F&action=edit&redlink=1" >对象的生命期<i class="fas fa-external-link-alt"></i></a>严格绑定，即由对象的<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" >构造函数<i class="fas fa-external-link-alt"></i></a>完成<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D&action=edit&redlink=1" >资源的分配<i class="fas fa-external-link-alt"></i></a>（获取），同时由<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" >析构函数<i class="fas fa-external-link-alt"></i></a>完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现<a class="link"   href="https://zh.wikipedia.org/w/index.php?title=%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2&action=edit&redlink=1" >资源泄露<i class="fas fa-external-link-alt"></i></a>问题。——<a class="link"   href="https://zh.wikipedia.org/wiki/RAII" >来自维基百科RAII<i class="fas fa-external-link-alt"></i></a></p><p>在写虚拟地址模块时，写了个<code>FrameTracker</code>结构，目的是记录每一个被分配的物理页号（PPN）,同时为其实现了<code>Drop Trait</code>，在其生命周期结束的时候会自动释放资源。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">stack_frame_dealloc</span>(<span class="keyword">self</span>.ppn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码写的差不多时，我进行测试，发现直接<code>LoadPageFault</code>，发现在进行虚拟页转换的时候，二级页表指向的指针居然是某个虚拟地址的物理地址，以至于访问次虚拟地址的时候直接<code>LoadPageFault</code>，调试2天毫无头绪。就在刚刚才想到可能原本的地址被释放了，然后再次分配了<code>Frame</code>，这本不应该发生。顺着这思路马上就找到了Bug，而我记得在写这段代码时十分满意。。。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span> = <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>),</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">stack_frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, f.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            f.ppn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_permission.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到Bug发生的原因是：<code>FrameTracker</code>实现了<code>Drop Trait</code>，这是一种RAII，在其生命周期结束的时候会自动释放资源，我直接使用了<code>clone()</code>，而导致生命周期在函数执行完时结束，接着释放了资源，对应的<code>PPN</code>即被标记为未分配的状态。</p><p>修复自然简单，不Clone不就完了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span> = <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>),</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">stack_frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ppn</span> = f.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, f);</span><br><span class="line">            ppn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_permission.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;常在河边走，哪有不湿鞋&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://unsafe.me/categories/OS/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust生命周期学习</title>
    <link href="https://unsafe.me/2021/01/31/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://unsafe.me/2021/01/31/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-31T12:38:41.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期学习"><a href="#生命周期学习" class="headerlink" title="生命周期学习"></a>生命周期学习</h2><h3 id="出个题目："><a href="#出个题目：" class="headerlink" title="出个题目："></a>出个题目：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NumRef</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; NumRef&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">change</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, num: &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> = num;</span><br><span class="line">        *<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_ref</span> = <span class="title function_ invoke__">NumRef</span>(&amp;<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题一：<em>以上代码编译是否会出错,为什么?如果会出错,怎么修改让它不出错？</em></li><li>问题二： <em>假如你已经解决了第一题，那代码这么写的会有什么局限性?</em> </li><li>问题三：<em>添加一行代码，证明第二题你所认为的局限性</em></li><li>问题四：<em>按照第二题你所认为的局限性,修改代码,消除局限性</em></li><li>问题五：<em>本题你学到了什么</em></li></ul><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ul><li><p>一，CV一把梭，就知道能编译过去了，所以答案是不会出错。</p></li><li><p>二，根据生命周期分析，<code>NumRef</code>和<code>change</code>方法中的<code>self</code>(注：<code>&amp;&#39;a mut self</code>是<code>self: &amp;&#39;a mut Self</code> 的简写)标记的生命周期都是<code>&#39;a</code>，可以理解为这个可变引用的生命周期和结构体的生命周期一样长，根据可变引用的独占性，<code>num_ref</code>一但调用<code>change</code>方法，之后其任何引用的使用都会触发借用检查的报错，所以局限性在于只能调用一次<code>change</code>方法(这样的应用很少)</p></li><li><p>三，添加<code>let _ = num_ref.change(&amp;7);</code>  触发报错：</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `num_ref` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">14</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">   |             ------- first mutable borrow occurs here</span><br><span class="line"><span class="number">14</span> |     <span class="keyword">let</span> <span class="variable">_</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">7</span>);</span><br><span class="line">   |             ^^^^^^^</span><br><span class="line">   |             |</span><br><span class="line">   |             second mutable borrow occurs here</span><br><span class="line">   |             first borrow later used here</span><br></pre></td></tr></table></figure><p>添加<code> println!(&quot;&#123;:?&#125;&quot;, num_ref);</code>   触发报错(<code>println!</code>使用了引用)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `num_ref` <span class="keyword">as</span> immutable because it is also borrowed <span class="keyword">as</span> mutable</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">15</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">a</span> = num_ref.<span class="title function_ invoke__">change</span>(&amp;<span class="number">6</span>);</span><br><span class="line">   |             ------- mutable borrow occurs here</span><br><span class="line"><span class="number">14</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line"><span class="number">15</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, num_ref);</span><br><span class="line">   |                      ^^^^^^^</span><br><span class="line">   |                      |</span><br><span class="line">   |                      immutable borrow occurs here</span><br><span class="line">   |                      mutable borrow later used here</span><br></pre></td></tr></table></figure><ul><li>四，删掉<code>&amp;&#39;a mut self</code>中的<code>&#39;a</code>即可</li><li>五，别瞎写生命周期参数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生命周期学习&quot;&gt;&lt;a href=&quot;#生命周期学习&quot; class=&quot;headerlink&quot; title=&quot;生命周期学习&quot;&gt;&lt;/a&gt;生命周期学习&lt;/h2&gt;&lt;h3 id=&quot;出个题目：&quot;&gt;&lt;a href=&quot;#出个题目：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Rust" scheme="https://unsafe.me/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>T and &#39;static</title>
    <link href="https://unsafe.me/2021/01/24/t-static/"/>
    <id>https://unsafe.me/2021/01/24/t-static/</id>
    <published>2021-01-24T13:42:41.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="T-‘static"><a href="#T-‘static" class="headerlink" title="T: ‘static"></a>T: ‘static</h1><h2 id="先看几个误区-直接摘抄自Rust生命周期常见误区"><a href="#先看几个误区-直接摘抄自Rust生命周期常见误区" class="headerlink" title="先看几个误区(直接摘抄自Rust生命周期常见误区)"></a>先看几个误区(直接摘抄自<a class="link"   href="https://github.com/whfuyn/rust-blog/blob/master/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3.md" >Rust生命周期常见误区<i class="fas fa-external-link-alt"></i></a>)</h2><h3 id="1-T-只包含所有权类型"><a href="#1-T-只包含所有权类型" class="headerlink" title="1) T 只包含所有权类型"></a>1) <code>T</code> 只包含所有权类型</h3><p>这个误解比起说生命周期，它和泛型更相关，但在Rust中泛型和生命周期是紧密联系在一起的，不可只谈其一。</p><p>当我刚开始学习Rust的时候，我理解<code>i32</code>，<code>&amp;i32</code>，和<code>&amp;mut i32</code>是不同的类型，也明白泛型变量<code>T</code>代表着所有可能类型的集合。<br>但尽管这二者分开都懂，当它们结合在一起的时候我却陷入困惑。在我这个Rust初学者的眼中，泛型是这样的运作的：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>类型变量</strong></td><td><code>T</code></td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr><tr><td><strong>例子</strong></td><td><code>i32</code></td><td><code>&amp;i32</code></td><td><code>&amp;mut i32</code></td></tr></tbody></table><p><code>T</code> 包含一切所有权类型； <code>&amp;T</code> 包含一切不可变借用类型； <code>&amp;mut T</code> 包含一切可变借用类型。<br><code>T</code>， <code>&amp;T</code>， 和 <code>&amp;mut T</code> 是不相交的有限集。 简洁明了，符合直觉，但却完全错误。<br>下面这才是泛型真正的运作方式：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>类型变量</strong></td><td><code>T</code></td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr><tr><td><strong>例子</strong></td><td><code>i32</code>, <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code>, …</td><td><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code>, …</td><td><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code>, …</td></tr></tbody></table><p><code>T</code>, <code>&amp;T</code>, 和 <code>&amp;mut T</code> 都是无限集, 因为你可以无限借用一个类型。<br><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code>的超集. <code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合。<br>让我们用几个例子来检验一下这些概念:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>上面的代码并不能如愿编译:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">error[E0119]: conflicting implementations of <span class="keyword">trait</span> `Trait` <span class="keyword">for</span> <span class="title class_">type</span> `&amp;_`:</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">5</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation <span class="keyword">for</span> `&amp;_`</span><br><span class="line"></span><br><span class="line">error[E0119]: conflicting implementations of <span class="keyword">trait</span> `Trait` <span class="keyword">for</span> <span class="title class_">type</span> `&amp;<span class="keyword">mut</span> _`:</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">7</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br><span class="line">  | ------------------- first implementation here</span><br><span class="line">...</span><br><span class="line"><span class="number">7</span> | <span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br><span class="line">  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation <span class="keyword">for</span> `&amp;<span class="keyword">mut</span> _`</span><br></pre></td></tr></table></figure><p>编译器不允许我们为<code>&amp;T</code>和<code>&amp;mut T</code>实现<code>Trait</code>，因为这样会与为<code>T</code>实现的<code>Trait</code>冲突，<br><code>T</code>本身已经包含了所有<code>&amp;T</code>和<code>&amp;mut T</code>。下面的代码能够如愿编译，因为<code>&amp;T</code>和<code>&amp;mut T</code>是不相交的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;T &#123;&#125; <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Trait <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code>的超集</li><li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li></ul><h3 id="2-如果-T-39-static-那么-T-必须在整个程序运行中都是有效的"><a href="#2-如果-T-39-static-那么-T-必须在整个程序运行中都是有效的" class="headerlink" title="2) 如果 T: &#39;static 那么 T 必须在整个程序运行中都是有效的"></a>2) 如果 <code>T: &#39;static</code> 那么 <code>T</code> 必须在整个程序运行中都是有效的</h3><p><strong>误解推论</strong></p><ul><li><code>T: &#39;static</code> 应该被看作 <em>“ <code>T</code> 拥有 <code>&#39;static</code> 生命周期 “</em></li><li><code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 没有区别</li><li>如果 <code>T: &#39;static</code> 那么 <code>T</code> 必须为不可变的</li><li>如果 <code>T: &#39;static</code> 那么 <code>T</code> 只能在编译期创建</li></ul><p>大部分Rust初学者是从类似下面这个代码示例中接触到 <code>&#39;static</code> 生命周期的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们被告知 <code>&quot;str literal&quot;</code> 是硬编码在编译出来的二进制文件中的，<br>并会在运行时被加载到只读内存，所以必须是不可变的且在整个程序的运行中都是有效的，<br>这就是它成为 <code>&#39;static</code> 的原因。<br>而这些观念又进一步被用 <code>static</code> 关键字来定义静态变量的规则所加强。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 编译错误，修改静态变量是unsafe的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认为静态变量</p><ul><li>只可以在编译期创建</li><li>必须是不可变的，修改它们是unsafe的</li><li>在整个程序的运行过程中都是有效的</li></ul><p><code>&#39;static</code> 生命周期大概是以静态变量的默认生命周期命名的，对吧？<br>那么有理由认为<code>&#39;static</code>生命周期也应该遵守相同的规则，不是吗？</p><p>是的，但拥有<code>&#39;static</code>生命周期的类型与<code>&#39;static</code>约束的类型是不同的。<br>后者能在运行时动态分配，可以安全地、自由地修改，可以被drop，<br>还可以有任意长度的生命周期。</p><p>在这个点，很重要的是要区分 <code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code>。</p><p><code>&amp;&#39;static T</code>是对某个<code>T</code>的不可变引用，这个引用可以被无限期地持有直到程序结束。<br>这只可能发生在<code>T</code>本身不可变且不会在引用被创建后移动的情况下。<br><code>T</code>并不需要在编译期就被创建，因为我们可以在运行时动态生成随机数据，<br>然后以内存泄漏为代价返回<code>&#39;static</code>引用，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时生成随机&amp;&#x27;static str</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    Box::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T: &#39;static</code> 是指<code>T</code>可以被无限期安全地持有直到程序结束。<br><code>T: &#39;static</code>包括所有<code>&amp;&#39;static T</code>，此外还包括所有的所有权类型，比如<code>String</code>, <code>Vec</code>等。<br>数据的所有者能够保证数据只要还被持有就不会失效，因此所有者可以无限期安全地持有该数据直到程序结束。<br><code>T: &#39;static</code>应该被看作“<code>T</code>受<code>&#39;static</code>生命周期约束”而非“<code>T</code>有着<code>&#39;static</code>生命周期”。<br>这段代码能帮我们阐释这些概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// 所有字符串都是随机生成的</span></span><br><span class="line">            <span class="comment">// 并且是在运行时动态申请的</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些字符串都是所有权类型，所以它们满足&#x27;static约束</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// 这些字符串都是可以修改的</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// 这些字符串都是可以被drop的</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// 编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这些字符串都在程序结束之前失效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ul><li><code>T: &#39;static</code> 应该被看作 <em><code>T</code>受<code>&#39;static</code>生命周期约束”</em></li><li>如果 <code>T: &#39;static</code> 那么<code>T</code>可以是有着<code>&#39;static</code>生命周期的借用类型</li><li>由于 <code>T: &#39;static</code> 包括了所有权类型，这意味着<code>T</code><ul><li>可以在运行时动态分配</li><li>不一定要在整个程序的运行过程中都有效</li><li>可以被安全地、自由地修改</li><li>可以在运行时被动态drop掉</li><li>可以有不同长度的生命周期</li></ul></li></ul><h2 id="我对T-’static的认识"><a href="#我对T-’static的认识" class="headerlink" title="我对T: ’static的认识"></a>我对T: ’static的认识</h2><p>上文中提到了对<code>T</code>， <code>&amp;T</code>， <code>&amp;mut T</code>和<code>&amp;&#39;static T</code>，<code>T: &#39;static</code>的误区，其中有这么一句话：*<code>T: &#39;static</code>包括所有<code>&amp;&#39;static T</code>，此外还包括所有的所有权类型，比如<code>String</code>, <code>Vec</code>等。* 所有权类型可以理解成不包含引用的类型，我们来试试是不是这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_str</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;t: &#x27;static test&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(s_str);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，编译通过了，<code>s_str</code>是<code>&amp;&#39;static</code>类型，<code>box_i32</code>是所有权类型。接下来我们稍微改改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(&amp;box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `box_i32` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:9:17</span><br><span class="line">   |</span><br><span class="line">9  |     static_test(&amp;box_i32);</span><br><span class="line">   |     ------------^^^^^^^^-</span><br><span class="line">   |     |           |</span><br><span class="line">   |     |           borrowed value does not live long enough</span><br><span class="line">   |     argument requires that `box_i32` is borrowed for `&#x27;static`</span><br><span class="line">10 | &#125;</span><br><span class="line">   | - `box_i32` dropped here while still borrowed</span><br></pre></td></tr></table></figure><p>报错了，不是说T是各种类型的集合吗，为什么不行呢？我们再改改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_test</span>&lt;T: <span class="symbol">&#x27;static</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_i32</span> = Box::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">static_test</span>(&amp;box_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译通过了，通过思考，恍然大悟，Rust到处存在模式匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">t: &amp;T,</span><br><span class="line">&amp;T: &amp;Box&lt;i32&gt;,</span><br><span class="line">T: Box&lt;i32&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就出现有意思的局面了，在<code>T: &#39;static</code>限定下，除了<code>&amp;&#39;static T</code>，其类型为，直接迎合了我们<code>T</code> 只包含所有权类型的误区，其例子为：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>类型变量</strong></td><td><code>T</code></td><td><code>&amp;T</code></td><td><code>&amp;mut T</code></td></tr><tr><td><strong>例子</strong></td><td><code>i32</code></td><td><code>&amp;i32</code>,  <code>&amp;mut i32</code></td><td><code>&amp;mut i32</code></td></tr></tbody></table><p>真有意思</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;T-‘static&quot;&gt;&lt;a href=&quot;#T-‘static&quot; class=&quot;headerlink&quot; title=&quot;T: ‘static&quot;&gt;&lt;/a&gt;T: ‘static&lt;/h1&gt;&lt;h2 id=&quot;先看几个误区-直接摘抄自Rust生命周期常见误区&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Rust" scheme="https://unsafe.me/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 宏(Macro)</title>
    <link href="https://unsafe.me/2021/01/16/rust-%E5%AE%8Fmacro/"/>
    <id>https://unsafe.me/2021/01/16/rust-%E5%AE%8Fmacro/</id>
    <published>2021-01-16T13:25:12.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rust-宏-Macro"><a href="#Rust-宏-Macro" class="headerlink" title="Rust 宏(Macro)"></a>Rust 宏(Macro)</h2><p>​ 众所周知, <em>Rust_提供了一个强大的宏系统，可进行元编程(metaprogramming)。_Rust</em> 中的宏几乎无处不在，其实你们写的第一个_Rust_ 程序里面就已经用到了宏，比如<code>println!</code>，宏看起来和函数很像，只不过名称末尾有一个感叹号 <code>!</code> 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。 ​ 由于才疏学浅，不敢班门弄斧，所以主要从例子出发，不深究原理，文章适合有_Rust_基础的同学看，官方文档 <a class="link"   href="https://doc.rust-lang.org/book/ch19-06-macros.html" >The Rust Programming Language<i class="fas fa-external-link-alt"></i></a> ​ 我的Github: <a class="link"   href="https://github.com/Spxg" >上铺小哥Spxg<i class="fas fa-external-link-alt"></i></a></p><h3 id="与C的宏有什么不同"><a href="#与C的宏有什么不同" class="headerlink" title="与C的宏有什么不同"></a>与C的宏有什么不同</h3><p>_C_的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define ONE_PLUE_ONE <span class="number">2</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ONE_PLUS_ONE);</span><br></pre></td></tr></table></figure><p>_Rust_的宏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> ONE_PLUS_ONE &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ONE_PLUS_ONE!());</span><br></pre></td></tr></table></figure><p>可能有同学要问了，_Rust_的宏与_C_的相比有什么不同。不同的是，_Rust_的宏会展开为抽象语法树(AST，abstract syntax tree)，而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。</p><h3 id="动手整个map"><a href="#动手整个map" class="headerlink" title="动手整个map!"></a>动手整个map!</h3><p>了解_Rust_的同学，相比对<code>vec!</code>不陌生，<code>vec![1, 2, 3]</code>相当于</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可见宏使用可以带来便捷，那我们可不可以为_HashMap_实现相似的功能呢，当然可以，考虑下面几行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     &quot;me&quot; =&gt; &quot;laji&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;you&quot; =&gt; &quot;good&quot;  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;me&quot;</span>, <span class="string">&quot;laji&quot;</span>);</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;you&quot;</span>, <span class="string">&quot;good&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们不妨设计成_key_ &#x3D;&gt; _value_的模式，像Ruby一样，将其插入到一个Map中，如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">marco_rule! map &#123;</span><br><span class="line">    <span class="comment">// $(...), + will be expanded for each matches </span></span><br><span class="line">    <span class="comment">// Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x</span></span><br><span class="line">    ($($key: expr =&gt; $value: expr), +) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        $(map.<span class="title function_ invoke__">insert</span>($key, $value);), +</span><br><span class="line">        map</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用map!来生成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">map</span> = map!(</span><br><span class="line">    <span class="string">&quot;me&quot;</span> =&gt; <span class="string">&quot;laji&quot;</span>,</span><br><span class="line">    <span class="string">&quot;you&quot;</span> =&gt; <span class="string">&quot;good&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不难发现，其精髓还是对号入座，可以在脑子里替换进去</p><h3 id="玩个大点的"><a href="#玩个大点的" class="headerlink" title="玩个大点的"></a>玩个大点的</h3><p>同学们都知道<code>fibonacci</code>数，我们都知道这列值可以永远持续下去，定义一个<code>fibonacci</code>的求值函数略显困难。显然，返回一整列值并不实际。我们真正需要的，应是某种具有惰性求值性质的东西——只在必要的时候才进行运算求值。 在Rust中，这样的需求表明，是<code>Iterator</code>派上用场的时候了。实现迭代器并不十分困难，但比较繁琐：你得自定义一个类型，弄明白该在其中存储什么，然后为它实现<code>Iterator</code> trait。 其实，递推关系足够简单；几乎所有的递推关系都可被抽象出来，变成一小段由宏驱动的代码生成机制。 但是我们不写<code>fibonacci</code>，写了就有点大材小用<del>脱裤子放屁</del>了，就为了一个<code>fibonacci</code>写宏多不值啊，编译器展开和自己写还不是一样。所以，我们整个比较通用的。</p><h4 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h4><p>同学们都是学过来的，想必都遇到过这些东西： <code>a = 1, 2, ..., n</code> <code>a = 1.0, ..., n * a[n - 1]</code> <code>fib = 0, 1, ..., fib[n - 1] + fib[n - 2]</code> 我们通过自己设计的宏假装实现一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recurrence!(a[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... n);</span><br><span class="line">recurrence!(a[n]: <span class="type">f64</span> = <span class="number">1.0</span> ... n * a[n - <span class="number">1</span>]);</span><br><span class="line">recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h4 id="列出方程"><a href="#列出方程" class="headerlink" title="列出方程"></a>列出方程</h4><p>以<code>fibonacci</code>为例， <code>fib[0] = 0</code> <code>fib[1] = 1</code> <code>fib[2] = fib[2 - 1] + fib[2 - 2] = 1</code> <code>fib[3] = fib[3 - 1] + fib[3 - 2] = 2</code> <code>......</code> 可以知道，我们只要有两个初始值就可以通过迭代算出任意一个<code>fibonacci</code>数，所以只需定义一个数组，列出方程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pseudocode</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">fib</span> = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = fib.<span class="title function_ invoke__">length</span>();</span><br><span class="line"><span class="keyword">if</span> n &lt; length &#123;</span><br><span class="line">    fib[n]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// offset is the times of iter</span></span><br><span class="line">    fib[n - <span class="number">1</span> - offset + length] + fib[n - <span class="number">2</span> - offset + length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计程序"><a href="#设计程序" class="headerlink" title="设计程序"></a>设计程序</h4><p>有了方程后，我们开始做更细化的操作，解决问题，如<code>fib[n - offset + length]</code>。有的同学就要问了：这有啥问题，不是很符合逻辑吗？的确很符合，但是有大坑啊，<code>n - 2 - offset</code> 在<code>n</code>为2开始的时候程序就panic了。原因是：在_Rust_中， 数组的Index是<code>usize</code>类型，必是大于等于0，<code>n</code>为2开始，其中间运算小于0，直接爆炸，所以我们需要改改逻辑：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">1</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = n <span class="keyword">as</span> <span class="type">i32</span> - <span class="number">2</span> - offset <span class="keyword">as</span> <span class="type">i32</span> + length <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">fib[a <span class="keyword">as</span> <span class="type">usize</span>] + fib[b <span class="keyword">as</span> <span class="type">usize</span>];</span><br></pre></td></tr></table></figure><p>看了以后，可能有些同学觉得这<del>尼玛是啥</del>太复杂了，很不美观，所以我们再想想。在_Rust_中，有个<code>std::num::Wrapping</code>类型，它就是干这事的，话不多说，看代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provides intentionally-wrapped arithmetic on T.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations like + on u32 values are intended to never overflow, and in some debug configurations overflow is detected and results in a panic. While most arithmetic falls into this category, some code explicitly expects and relies upon modular arithmetic (e.g., hashing).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrapping arithmetic can be achieved either through methods like wrapping_add, or through the Wrapping&lt;T&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The underlying value can be retrieved through the .0 index of the Wrapping tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Wrapping</span>(n);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(offset);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">length</span> = <span class="title function_ invoke__">Wrapping</span>(length);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">real_index</span> = n - offset + length;</span><br><span class="line">fib[real_index.<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>总算比上面一坨好看多了。</p><h4 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h4><p><em>Rust</em> 提供了Iterator trait，使我们更好使用，而且还有好多实现了Iterator类型的方法，用它就完了，trait 长这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span></span><br><span class="line"><span class="comment">//  The type of the elements being iterated over.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Required methods</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"><span class="comment">//  Advances the iterator and returns the next value.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns None when iteration is finished. Individual iterator implementations may choose to resume iteration, and so calling next() again may or may not eventually start returning Some(Item) again at some point.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_Rust_中，<code>[]</code>操作来源于<code>Index&lt;T&gt;</code> trait, 其中的<code>T</code>就是Index的类型，在这里就是<code>usize</code>，<code>Index&lt;T&gt;</code> trait 长这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Index</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>: ?<span class="built_in">Sized</span></span><br><span class="line">    <span class="comment">// The returned type after indexing.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required methods</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, index: Idx) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Output</span><br><span class="line">    <span class="comment">// Performs the indexing (container[index]) operation.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接开始写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Index;</span><br><span class="line"><span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    mem: [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    pos: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            mem: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            pos: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    slice: &amp;<span class="symbol">&#x27;a</span> [<span class="type">u32</span>; MEM_SIZE],</span><br><span class="line">    offset: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline(always)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">        &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="keyword">self</span>.pos;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fib</span> = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset &#125;;</span><br><span class="line">                fib[offset - <span class="number">1</span>] + fib[offset - <span class="number">2</span>]</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// move forward</span></span><br><span class="line">                <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fib</span> = Solution::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter 10 times</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">f</span> <span class="keyword">in</span> fib.<span class="title function_ invoke__">take</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行一把梭，轻松秒杀：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><p>有了这个经验，写宏就很简单了，首先要解决的是，怎么让宏知道你初始有几个元素？套娃就对了！直接上代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        $recur</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一波：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> ... fib[n - <span class="number">1</span>] * fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: `$inits:expr` may be followed by `...`, which is not allowed <span class="keyword">for</span> `expr` fragments</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">8</span>:<span class="number">62</span></span><br><span class="line">  </span><br><span class="line"><span class="number">8</span>      ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + ... $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">                                                                ^^^ not allowed after `expr` fragments</span><br><span class="line">  </span><br><span class="line">  = note: allowed there are: `=&gt;`, `,` or `;`</span><br></pre></td></tr></table></figure><p>看来是不能用<code>...</code>了，那我们换成<code>=&gt;</code></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> count_exprs &#123;</span><br><span class="line">    () =&gt; &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ($head: expr) =&gt; &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    ($head: expr, $($tail: expr), *) =&gt; &#123; <span class="number">1</span> + count_exprs!($($tail), *) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> recurrence &#123;</span><br><span class="line">    ($seq: ident[$ind: ident]: $sty: ty = $($inits: expr), + =&gt; $recur: expr) =&gt; &#123; &#123;</span><br><span class="line">        <span class="keyword">use</span> std::ops::Index;</span><br><span class="line">        <span class="keyword">const</span> MEM_SIZE: <span class="type">usize</span> = count_exprs!($($inits: expr), +);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            mem: [$sty; MEM_SIZE],</span><br><span class="line">            pos: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            slice: &amp;<span class="symbol">&#x27;a</span> [$sty; MEM_SIZE],</span><br><span class="line">            offset: <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Index&lt;<span class="type">usize</span>&gt; <span class="keyword">for</span> <span class="title class_">IndexOffset</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Output</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline(always)]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">index</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">                <span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">index</span> = <span class="title function_ invoke__">Wrapping</span>(index);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">offset</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="keyword">self</span>.offset);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">window</span> = <span class="title function_ invoke__">Wrapping</span>(MEM_SIZE);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">real_index</span> = index - offset + window;</span><br><span class="line">                &amp;<span class="keyword">self</span>.slice[real_index.<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">            <span class="keyword">type</span> <span class="title class_">Item</span> = $sty;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[inline]</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.pos &lt; MEM_SIZE &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">value</span> = <span class="keyword">self</span>.mem[<span class="keyword">self</span>.pos];</span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">next_val</span> = &#123;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $ind = <span class="keyword">self</span>.pos;</span><br><span class="line">                        <span class="meta">#[allow(unused)]</span></span><br><span class="line">                        <span class="keyword">let</span> $seq = IndexOffset &#123; slice: &amp;<span class="keyword">self</span>.mem, offset: $ind &#125;;</span><br><span class="line">                        ($recur)</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">use</span> std::mem::swap;</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">swap_tmp</span> = next_val;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..MEM_SIZE).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">                            <span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> swap_tmp, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.mem[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.pos += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(next_val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Solution &#123; mem: [$($inits), +], pos: <span class="number">0</span> &#125;</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = recurrence!(s1[n]: <span class="type">usize</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; n);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1.take(6) is&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = recurrence!(s2[n]: <span class="type">f64</span> = <span class="number">1.0</span> =&gt; s2[n - <span class="number">1</span>] * n <span class="keyword">as</span> <span class="type">f64</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>).<span class="title function_ invoke__">fold</span>(<span class="number">0.0</span>, acc, x acc + x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2.take(3)&#x27;s sum is &#123;&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = recurrence!(s3[n]: <span class="type">usize</span> = <span class="number">1</span> =&gt; n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3.take(5) is &#123;:?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fib</span> = recurrence!(fib[n]: <span class="type">u32</span> = <span class="number">0</span>, <span class="number">1</span> =&gt; fib[n - <span class="number">1</span>] + fib[n - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sixth</span> = fib.<span class="title function_ invoke__">nth</span>(<span class="number">6</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the sixth of fibonacci is &#123;&#125;&quot;</span>, sixth);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;RUST NB!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="title function_ invoke__">take</span>(<span class="number">6</span>) is</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-------------</span><br><span class="line">s2.<span class="title function_ invoke__">take</span>(<span class="number">3</span>)<span class="symbol">&#x27;s</span> sum is <span class="number">4</span></span><br><span class="line">-------------</span><br><span class="line">s3.<span class="title function_ invoke__">take</span>(<span class="number">5</span>) is [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">-------------</span><br><span class="line">the sixth of fibonacci is <span class="number">8</span></span><br><span class="line">-------------</span><br><span class="line">RUST NB!</span><br></pre></td></tr></table></figure><h3 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h3><ul><li><p><a class="link"   href="https://danielkeep.github.io/tlborm/" >The Little Book of Rust Macros<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://doc.rust-lang.org/book/title-page.html" >The Rust Programming Language<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Rust-宏-Macro&quot;&gt;&lt;a href=&quot;#Rust-宏-Macro&quot; class=&quot;headerlink&quot; title=&quot;Rust 宏(Macro)&quot;&gt;&lt;/a&gt;Rust 宏(Macro)&lt;/h2&gt;&lt;p&gt;​ 众所周知, &lt;em&gt;Rust_提供了一个强大的宏系统</summary>
      
    
    
    
    <category term="Rust" scheme="https://unsafe.me/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>FAT32 FileSystem Library</title>
    <link href="https://unsafe.me/2020/10/16/fat32-filesystem-library/"/>
    <id>https://unsafe.me/2020/10/16/fat32-filesystem-library/</id>
    <published>2020-10-16T16:15:31.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a class="link"   href="https://github.com/Spxg/fat32" >Github<i class="fas fa-external-link-alt"></i></a></h1><p><a href="https://crates.io/crates/fat32"><img src="https://img.shields.io/crates/v/fat32.svg" alt="crates.io version"></a> This is FAT32 FileSystem Library, which is <code>#![no_std]</code> and does not use <code>alloc</code>. Test passed with <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> and WindowsAPI.</p><h2 id="Supported-Features"><a href="#Supported-Features" class="headerlink" title="Supported Features"></a>Supported Features</h2><ul><li>[x] Read</li><li>[x] Create File AND Dir</li><li>[x] Write(OverWritten and Append)</li><li>[x] Delete File AND DIR</li></ul><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="My-Device-Support-std-Can-I-Use-This-Crate"><a href="#My-Device-Support-std-Can-I-Use-This-Crate" class="headerlink" title="My Device Support std, Can I Use This Crate?"></a>My Device Support <code>std</code>, Can I Use This Crate?</h3><p>Of course you can, but I don’t recommend it. You should use <code>std::fs::File</code> OR other crates.</p><h3 id="Why-Do-You-Write-This-Crate"><a href="#Why-Do-You-Write-This-Crate" class="headerlink" title="Why Do You Write This Crate?"></a>Why Do You Write This Crate?</h3><p>In order to support devices and environment which don’t have <code>std</code>, like * Embedded Device * Bootloader</p><h3 id="Have-More-Examples"><a href="#Have-More-Examples" class="headerlink" title="Have More Examples?"></a>Have More Examples?</h3><ul><li><a class="link"   href="https://github.com/play-stm32/bootloader" >Embedded Device’s Bootloader<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="How-To-Test-Only-Windows"><a href="#How-To-Test-Only-Windows" class="headerlink" title="How To Test (Only Windows)"></a>How To Test (Only Windows)</h2><ul><li>EDIT mount() function in lib.rs, change disk like <code>\\\\.\\E:</code></li><li><code>cargo test</code></li></ul><h2 id="How-To-Use"><a href="#How-To-Use" class="headerlink" title="How To Use"></a>How To Use</h2><p>You need make your library implement <a href="https://github.com/Spxg/block_device"><code>BlockDevice</code> trait</a>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BlockDevice</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For example, I use my another library <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> to implement:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">BlockDevice</span> <span class="keyword">for</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = CmdError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>, buf: &amp;<span class="keyword">mut</span> [<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> number_of_blocks == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">read_block</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">read_multi_blocks</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>, number_of_blocks <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>], address: <span class="type">usize</span>, number_of_blocks: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> number_of_blocks == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">write_block</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">write_multi_blocks</span>(buf, address <span class="keyword">as</span> <span class="type">u32</span>, number_of_blocks <span class="keyword">as</span> <span class="type">u32</span>)?</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now <a class="link"   href="https://github.com/play-stm32/sdio_sdhc" >sdio_sdhc<i class="fas fa-external-link-alt"></i></a> library supported fat32 filesystem. Then, add fat32 library to your application</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># if no feature config, the BUFFER_SIZE is 512 Bytes</span><br><span class="line">fat32 = &quot;0.2&quot;</span><br></pre></td></tr></table></figure><p>If your card block is other size, like 1024 Bytes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies.fat32]</span><br><span class="line">version = &quot;0.2&quot;</span><br><span class="line">default-features = false</span><br><span class="line">features = [&quot;1024&quot;]</span><br></pre></td></tr></table></figure><p>Then, you can do some tests</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card from sdio_sdhc crate</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">card</span> = Card::<span class="title function_ invoke__">init</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// Volume from fat32 crate</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cont</span> = Volume::<span class="title function_ invoke__">new</span>(card);</span><br><span class="line"><span class="comment">// cd root dir</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">root</span> = cont.<span class="title function_ invoke__">root_dir</span>();</span><br><span class="line"><span class="comment">// create file named test.txt</span></span><br><span class="line">root.<span class="title function_ invoke__">create_file</span>(<span class="string">&quot;test.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// open file</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = root.<span class="title function_ invoke__">open_file</span>(<span class="string">&quot;test.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// write buffer to file</span></span><br><span class="line">file.<span class="title function_ invoke__">write</span>(&amp;[<span class="number">80</span>; <span class="number">1234</span>]).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>If all goes well, the file was created with 1234 Bytes in root dir.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://github.com/Spxg/fat32&quot; &gt;Github&lt;i cla</summary>
      
    
    
    
    <category term="Rust" scheme="https://unsafe.me/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>eHallTools-天津理工大学网上办事大厅工具</title>
    <link href="https://unsafe.me/2019/11/29/ehalltools-%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BE%BF%E5%88%A9%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://unsafe.me/2019/11/29/ehalltools-%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BE%BF%E5%88%A9%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2019-11-29T16:05:48.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="1-8-5"><a href="#1-8-5" class="headerlink" title="1.8.5"></a>1.8.5</h3><ul><li>20200103更新</li><li>选课结果查看</li><li>添加关于软件</li></ul><h3 id="1-8-0"><a href="#1-8-0" class="headerlink" title="1.8.0"></a>1.8.0</h3><ul><li>20191231更新</li><li>添加当前登录功能</li></ul><h3 id="1-7-5"><a href="#1-7-5" class="headerlink" title="1.7.5"></a>1.7.5</h3><ul><li>20191231更新</li><li>使用XPath提取HTML数据</li><li>修复Bug</li></ul><h3 id="1-7-0"><a href="#1-7-0" class="headerlink" title="1.7.0"></a>1.7.0</h3><ul><li>20191230更新</li></ul><h2 id="使用前必看"><a href="#使用前必看" class="headerlink" title="使用前必看"></a>使用前必看</h2><ul><li>软件采用.Net Core WPF开发, 需下载安装运行时才能正常运行<a class="link"   href="https://dotnet.microsoft.com/download" >.Net Core Runtime<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="什么是eHallTools"><a href="#什么是eHallTools" class="headerlink" title="什么是eHallTools?"></a>什么是eHallTools?</h2><ul><li>一个小软件，用于方便的查看大学eHall网站上的信息，针对天津理工大学eHall进行的开发，由于不知道其他学校eHall有没有通知公告等功能，故不一定通用</li></ul><h2 id="为什么开发它"><a href="#为什么开发它" class="headerlink" title="为什么开发它"></a>为什么开发它</h2><ul><li>初学C#，想写一些项目学习并巩固知识</li></ul><h2 id="软件功能"><a href="#软件功能" class="headerlink" title="软件功能"></a>软件功能</h2><ul><li>通知公告</li><li>师生服务（实现考试安排查询, 成绩查询, 选课结果查看）</li><li>当前登录</li></ul><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul><li>登录界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129224021.png" alt="登录界面"></li></ul><p>学校服务地址配置存储格式，可编辑添加（&#x2F;config&#x2F;server.json）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Info&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;University&quot;</span>: <span class="string">&quot;天津理工大学&quot;</span>,</span><br><span class="line">      <span class="string">&quot;AuthserverHttp&quot;</span>: <span class="string">&quot;http://authserver.tjut.edu.cn&quot;</span>,</span><br><span class="line">      <span class="string">&quot;EhallHttp&quot;</span>: <span class="string">&quot;http://ehall.tjut.edu.cn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在页面添加 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129225250.png" alt="添加服务界面"> 或删除 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129230058.png" alt="删除服务界面"> 账号密码等信息的保存（&#x2F;config&#x2F;settings.json）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;RememberPassword&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;AutoLogin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;SelectedUniversityIndex&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;StudentId&quot;</span>: <span class="string">&quot;11111&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Password&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用选择"><a href="#应用选择" class="headerlink" title="应用选择"></a>应用选择</h3><ul><li>应用选择界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129230229.png" alt="应用选择界面"></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="通知公告"><a href="#通知公告" class="headerlink" title="通知公告"></a>通知公告</h3><ul><li><p>界面 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130925.png" alt="通知公告"></p></li><li><p>双击看详情，如有文件，双击下载（&#x2F;downloads&#x2F;标题） <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130835.png" alt="详情"></p></li><li><p>输入进行搜索 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130802.png" alt="搜索"></p></li></ul><h3 id="考试安排查询"><a href="#考试安排查询" class="headerlink" title="考试安排查询"></a>考试安排查询</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130655.png" alt="考试安排查询"></p><h3 id="成绩查询"><a href="#成绩查询" class="headerlink" title="成绩查询"></a>成绩查询</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230130715.png" alt="成绩查询"></p><h3 id="选课结果查看"><a href="#选课结果查看" class="headerlink" title="选课结果查看"></a>选课结果查看</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20200103211502.png" alt="选课结果查看"></p><h3 id="当前登录"><a href="#当前登录" class="headerlink" title="当前登录"></a>当前登录</h3><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191231223602.png" alt="当前登录"></p><ul><li>双击踢出设备</li><li>一键踢出所有设备</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>对于某些通知，处理的并不好（没法看）如以下通知，因技术有限，处理成一坨, 如需查看，双击通知内容进入浏览器解析 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191129231746.png" alt="案例"></p></li><li><p>并不需要连接校园网，但是校园网访问很快！</p></li><li><p>添加删除服务地址后，回主页面更新即可</p></li><li><p>电信用户使用可能使用不太顺畅，这是没办法的事，原因是电信绕路 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/12/QQ%E6%88%AA%E5%9B%BE20191230131933.png" alt="辣鸡电信"></p></li></ul><h2 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h2><ul><li><a class="link"   href="https://github.com/Spxg/eHallTools/releases/download/v1.8.5/eHallTools.zip" >eHallTools<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li><a class="link"   href="https://github.com/Spxg/eHallTools" >eHallToolsSource<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul><li><a class="link"   href="https://github.com/itswait" >Wait<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;更新日志&quot;&gt;&lt;a href=&quot;#更新日志&quot; class=&quot;headerlink&quot; title=&quot;更新日志&quot;&gt;&lt;/a&gt;更新日志&lt;/h2&gt;&lt;h3 id=&quot;1-8-5&quot;&gt;&lt;a href=&quot;#1-8-5&quot; class=&quot;headerlink&quot; title=&quot;1.8.5&quot;&gt;</summary>
      
    
    
    
    <category term="C Sharp" scheme="https://unsafe.me/categories/C-Sharp/"/>
    
    
  </entry>
  
  <entry>
    <title>GPS数据处理-C#版</title>
    <link href="https://unsafe.me/2019/10/05/gps%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-c-sharp%E7%89%88/"/>
    <id>https://unsafe.me/2019/10/05/gps%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-c-sharp%E7%89%88/</id>
    <published>2019-10-05T07:37:49.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<p><em>C版本见这</em></p><p><a href="https://unsafe.me/archives/567">C语言程序设计CAP-第10章编程题-GPS数据处理</a></p><p>国庆总得给自己找点事做，不打游戏，不想做作业，还能干啥?</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Gps gps = <span class="keyword">new</span> Gps();</span><br><span class="line">            <span class="built_in">string</span> hour = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> minute = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> second = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">            str = Convert.ToString(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!str.Equals(<span class="string">&quot;END&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (gps.CheckHeader(str) &amp;&amp; gps.CheckNum(str) &amp;&amp; gps.CheakLocated(str))</span><br><span class="line">                &#123;</span><br><span class="line">                    hour = gps.GetHour(str);</span><br><span class="line">                    minute = gps.GetMinute(str);</span><br><span class="line">                    second = gps.GetSecond(str);</span><br><span class="line">                &#125;</span><br><span class="line">                str = Convert.ToString(Console.ReadLine());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(hour + <span class="string">&quot;:&quot;</span> + minute + <span class="string">&quot;:&quot;</span> + second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Gps</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckHeader</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str.Substring(<span class="number">0</span>, <span class="number">6</span>).Equals(<span class="string">&quot;$GPRMC&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckNum</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对比C版，对异或值的计算更合理。</span></span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line">            <span class="built_in">int</span> xornum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; str[i] != <span class="string">&#x27;*&#x27;</span>; i++)</span><br><span class="line">                xornum ^= str[i];</span><br><span class="line">            xornum %= <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Convert.ToString(xornum, <span class="number">16</span>).Equals(str.Substring(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheakLocated</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">7</span>; str[i] != <span class="string">&#x27;,&#x27;</span>; i++)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> str[i + <span class="number">1</span>].Equals(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetHour</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> hour = (str[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">8</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            hour = (hour + <span class="number">8</span>) % <span class="number">24</span>;</span><br><span class="line">            <span class="keyword">return</span> hour.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetMinute</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> minute = (str[<span class="number">9</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">10</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> minute.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetSecond</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> second = (str[<span class="number">11</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[<span class="number">12</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> second.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;C版本见这&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://unsafe.me/archives/567&quot;&gt;C语言程序设计CAP-第10章编程题-GPS数据处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国庆总得给自己找点事做，不打游戏，不想做作业，还能干啥?&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="C Sharp" scheme="https://unsafe.me/categories/C-Sharp/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio Code C/C++环境配置</title>
    <link href="https://unsafe.me/2019/09/20/visual-studio-code-c%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://unsafe.me/2019/09/20/visual-studio-code-c%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2019-09-20T14:04:34.000Z</published>
    <updated>2022-04-05T12:46:56.143Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Studio Code 与 Visual Studio IDE 的区别</p><p>根据<a class="link"   href="https://code.visualstudio.com/docs/supporting/faq#_what-is-the-difference-between-visual-studio-code-and-visual-studio-ide" >官方的说法<i class="fas fa-external-link-alt"></i></a>有</p><h2 id="What-is-the-difference-between-Visual-Studio-Code-and-Visual-Studio-IDE"><a href="#What-is-the-difference-between-Visual-Studio-Code-and-Visual-Studio-IDE" class="headerlink" title="What is the difference between Visual Studio Code and Visual Studio IDE?#"></a>What is the difference between Visual Studio Code and Visual Studio IDE?<a class="link"   href="https://code.visualstudio.com/docs/supporting/faq#_what-is-the-difference-between-visual-studio-code-and-visual-studio-ide" >#<i class="fas fa-external-link-alt"></i></a></h2><p>Visual Studio Code is a streamlined code editor with support for development operations like debugging, task running, and version control. It aims to provide just the tools a developer needs for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs, such as <a class="link"   href="https://visualstudio.microsoft.com/" >Visual Studio IDE<i class="fas fa-external-link-alt"></i></a>. 按照我的理解就是前者是个轻量级代码编辑器， 手动装好拓展和相关的编译器，就可以编写调试相应的程序，主要针对文件而不是项目，是Sublime或Atom on Electron的竞争对手；而Visual Studio IDE一看“IDE”就感觉不简单， IDE即Integrated Development Environment， 是个集成开发环境，微软旨在让其成为世界上最好的IDE，其功能强大的同时程序也不小。相比之下，Visual Studio 才是我们初选者的选择。</p><p>安装Visual Studio Code</p><p>Visual Studio Code 支持的平台有自家的Windows， MacOS，以及Linux，<a class="link"   href="https://code.visualstudio.com/" >点我跳官网下载<i class="fas fa-external-link-alt"></i></a>，但是Visual Studio Code 在Windows上配置相对麻烦（在MacOS直接编译C程序时，其系统会自动弹出安装GCC的选项；在Linux应该装个GCC就好了（这个我还真没试过））,直接全选了，毕竟还挺实用的，然后安装即可。 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920202803.png"></p><p>配置Visual Studio Code</p><p>先创建一个写代码的地方吧，比如Code，然后随意在其中创建一个C文件，会弹出下载C拓展的选项，点击安装（Install）即可，如图 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920203656.png"> 拓展是有了，但是编译器还没，根据<a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw" >官方文档<i class="fas fa-external-link-alt"></i></a>，使用的是<a class="link"   href="http://mingw-w64.org/doku.php/start" >Mingw<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download" >下载地址<i class="fas fa-external-link-alt"></i></a>，打开安装程序，如下图选择（应该没人用32位了吧<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">） <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20191127191914.png"> 这里以我的安装目录为演示，以下步骤都以这个目录为示范，目录不同请自行修改下面的配置文件 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20191127192158.png"> 然后在终端打入path</p><p>setx path “%path%;c:\Software\mingw64\bin”</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920205756.png"> 接下来生成配置文件，进入Code文件夹，按下Ctrl+Shift+P， 如图选择 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210340.png"> 然后我们输入path地址及选择编译器 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210455.png"> 我修改了标准参数（c11-&gt;c99) <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920210536.png"> 接下来创建task.json, 官方有</p><h2 id="Create-a-build-task"><a href="#Create-a-build-task" class="headerlink" title="Create a build task#"></a>Create a build task<a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw#_create-a-build-task" >#<i class="fas fa-external-link-alt"></i></a></h2><p>Next, create a <code>tasks.json</code> file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler to create an executable file based on the source code.</p><ol><li><p>From the main menu, choose <strong>View &gt; Command Palette</strong> and then type “task” and choose <strong>Tasks: Configure Default Build Task</strong>. In the dropdown, select <strong>Create tasks.json file from template</strong>, then choose <strong>Others</strong>. VS Code creates a minimal <code>tasks.json</code> file and opens it in the editor. （可以直接在.vscode中创建个task.json,然后copy进去保存即可）</p></li><li><p>Go ahead and replace the entire file contents with the following code snippet （下面是我的配置）:</p><p>{<br>“tasks”: [<br>    {<br>        “type”: “shell”,<br>        “label”: “Build”,<br>        “command”: “D:\\Software\\mingw64\\bin\\gcc.exe”,<br>        “args”: [<br>            “-g”,<br>            “${file}”,<br>            “-o”,<br>            “${fileDirname}\\${fileBasenameNoExtension}.exe”,<br>            “-std&#x3D;gnu99”,<br>            “-fexec-charset&#x3D;GBK”,<br>            “-finput-charset&#x3D;UTF-8”<br>        ],<br>        “options”: {<br>            “cwd”: “D:\\Software\\mingw64\\bin”<br>        },<br>        “group”: {<br>            “kind”: “build”,<br>            “isDefault”: true<br>        },<br>        “presentation”: {<br>            “reveal”: “silent”<br>        }<br>    }<br>],<br>“version”: “2.0.0”<br>}</p></li></ol><pre><code> </code></pre><p>官方对于launch.json有</p><h2 id="Configure-debug-settings"><a href="#Configure-debug-settings" class="headerlink" title="Configure debug settings"></a>Configure debug settings</h2><p>Next, we’ll configure VS Code to launch the GCC debugger (gdb.exe) when you press F5.</p><ol><li>From the Command Palette, type “launch” and then choose <strong>Debug: Open launch.json</strong>. Next, choose the <strong>GDB&#x2F;LLDB</strong> environment.</li><li>For <code>program</code>, use the program name <code>helloworld.exe</code> (which matches what you specified in <code>tasks.json</code>). You will need to adjust your <code>miDebuggerPath</code> value to match the path to your Mingw-w64 installation.</li><li>By default, the C++ extension adds a breakpoint to the first line of <code>main</code>. The <code>stopAtEntry</code> value is set to <code>true</code> to cause the debugger to stop on that breakpoint. You can set this to <code>false</code> if you prefer to ignore it.</li><li>Optionally, set <code>externalConsole</code> to <code>true</code> to run the program in an external console.</li></ol><p>Your complete <code>launch.json</code> file should look something like this （已修改，可以直接在.vscode中创建个launch.json,然后copy进去保存即可）:</p><p>{<br>    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.<br>    &#x2F;&#x2F; Hover to view descriptions of existing attributes.<br>    &#x2F;&#x2F; For more information, visit: <a class="link"   href="https://go.microsoft.com/fwlink/?linkid=830387" >https://go.microsoft.com/fwlink/?linkid=830387<i class="fas fa-external-link-alt"></i></a><br>    “version”: “0.2.0”,<br>    “configurations”: [</p><pre><code>    &#123;        &quot;name&quot;: &quot;gcc.exe build and debug active file&quot;,        &quot;type&quot;: &quot;cppdbg&quot;,        &quot;request&quot;: &quot;launch&quot;,        &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,        &quot;args&quot;: \[\],        &quot;stopAtEntry&quot;: false,        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,        &quot;environment&quot;: \[\],        &quot;externalConsole&quot;: false,        &quot;MIMode&quot;: &quot;gdb&quot;,        &quot;miDebuggerPath&quot;: &quot;D:\\\\Software\\\\mingw64\\\\bin\\\\gdb.exe&quot;,        &quot;setupCommands&quot;: \[            &#123;                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                &quot;ignoreFailures&quot;: true            &#125;        \],        &quot;preLaunchTask&quot;: &quot;Build&quot;    &#125;\]</code></pre><p>}</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920212812.png"> 全部创建完成后，即可在该目录下写C了，换目录时记得把.vscode文件复制过去</p><p>Visual Studio Code 的功能</p><p>编译运行当然没有问题</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213458.png"></p><p>调试当然正常</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213608.png"></p><p>代码补全当然好用</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213655.png"></p><p>还有很好的规范学习工具——格式化功能</p><p><img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920213747.png"></p><p>安装中文拓展</p><p>进入拓展，搜索安装并重启软件即可 <img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/09/QQ%E6%88%AA%E5%9B%BE20190920214456.png"></p><p>对于一些功能的思考</p><ol><li>代码补全对于我这种新手来说有利也有弊，利的方面自然是写的快了，但可能会因此忘掉语法的写法，这是致命的（上机考试的软件可没有代码补全），所以我这种新手觉得还是多自己写写，而代码补全可以作为学习的工具来研究语法该怎样写</li><li>格式化代码是个好东西，它可以让我们的代码更规范，但是我们不能因为这功能而写出杂乱的代码，我们应该学习如何写，格式化的代码值得研究</li></ol><p>相关文件（供网络不通<img src="https://wordpress-1253676827.file.myqcloud.com/wp-content/uploads/2019/07/5b6603441f7e1552.png">的朋友下载）及懒人直接配置文件（copy大法好）</p><p><a class="link"   href="https://spxg-my.sharepoint.com/:f:/g/personal/spxg_spxg_me/Ev-LK1V5bStGk4b6_8hSw9ABnV2_X9prihAWeJY19tVBlw?e=CoXdwY" >一键轻松<i class="fas fa-external-link-alt"></i></a></p><p> </p><p>引用文章</p><ol><li><a class="link"   href="https://code.visualstudio.com/docs/cpp/config-mingw" >Using Mingw-w64 in VS Code<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/weibo1230123/article/details/89259510" >Visual Studio 2017和Visual Studio Code的区别！<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Visual Studio Code 与 Visual Studio IDE 的区别&lt;/p&gt;
&lt;p&gt;根据&lt;a class=&quot;link&quot;   href=&quot;https://code.visualstudio.com/docs/supporting/faq#_what-is-th</summary>
      
    
    
    
    <category term="技术相关" scheme="https://unsafe.me/categories/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
</feed>
